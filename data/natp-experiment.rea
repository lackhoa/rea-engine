#load "nat.rea"

Natp :: union {1, ++(p: Natp)}

;; literal translation
nat :: fn(a: Natp) -> Nat
{fork a {1: 1, ++: ++(nat(a.p))}}

natp :: fn(a: Nat) -> Natp
{fork a {0  1,  ;; throwaway case
         ++ fork a.p {0  1,
                      ++ ++(natp(a.p))}}}

natpNot0 :: (a: Natp) -> nat(a) != 0
{fork a {1 id(False), ++ id(False)}}

+ :: fn(a,b: Natp) -> Natp
{;; prove(nat(a) + nat(b) != 0) {addPos(nat(a), nat(b), natpNot0(a))};
 natp(nat(a) + nat(b))}

* :: fn(a,b: Natp) -> Natp
{;; prove(nat(a) * nat(b) != 0) {mulPos(nat(a), nat(b), natpNot0(a), natpNot0(b))};
 natp(nat(a) * nat(b))}

addCommutative :: (a,b: Natp) -> (b+a = a+b)
{
 => natp(nat(b) + nat(a)) = natp(nat(a) + nat(b));
 => natp(nat(a) + nat(b)) = natp(nat(a) + nat(b)) {addCommutative}
 }

;; todo this falsehood proving business is still annoying
natpS :: (a: Nat, not0: a!=0) -> natp(++(a)) = ++(natp(a))
{fork a {0 norm not0; falsehood := not0(_); fork falsehood {},
         ++}}

natpNot0 :: (a: Natp) -> nat(a) != 0
{fork a {1 id(False), ++ id(False)}}

natInjective :: (a: Natp) -> natp(nat(a)) = a
{fork a {1 ,
         ++
         => natp(++(nat(a.p))) = ++(a.p);
         => ++(natp(nat(a.p))) = ++(a.p) { natpS(nat(a.p), natpNot0(a.p)) }
         => ++(a.p) = ++(a.p) { natInjective }
         }}

natpInjective :: (a: Nat) -> nat(natp(++(a))) = ++(a)
{fork a {0  ,
         ++ => ++(++(a.p)) = ++(++(a.p)) {natpInjective(a.p)}}}

natPreservesAddition :: (a,b: Natp) -> nat(a) + nat(b) = nat(a+b)
{fork a {1  rewrite natpInjective(nat(b)),
         ++
         rewrite natInjective(nat(a.p) + nat(b));
         }}

addAssociative :: (a,b,c: Natp) -> (a+b)+c = a+b+c
{
 => natp(nat(natp(nat(a) + nat(b))) + nat(c)) = natp(nat(a) + nat(natp(nat(b) + nat(c))));
 }

mulDistributive :: (a,b,c: Natp) -> a*c+b*c = (a+b)*c
{
 => +++((c.p + a.p * ++(c.p)) + ++(c.p + b.p * ++(c.p))) = +++(c.p + (a.p + ++(b.p)) * ++(c.p))
 => +++((c.p + a.p * ++(c.p)) + ++(c.p + b.p * ++(c.p))) = +++(c.p + (a.p + ++(b.p)) * ++(c.p))
 }

mulAssociative :: (a,b,c: Natp) -> (a*b)*c = a*b*c
{fork a
 {1 : ,
  ++:
  rewrite <- mulDistributive(b, (a.p * b), c);
  rewrite mulAssociative(a.p, b, c)}}

mul1 :: (a: Natp) -> a*1 = a
{fork a
 {1 : ,
  ++: rewrite mul1(a.p)}}
;; print mul1;

mulSRight :: (a,b: Natp) -> a * ++(b) = a + a*b
{fork a
 {1:,
  ++:
  => ++(b + a.p * ++(b))   = ++(a.p + b + a.p*b)
  => ++(b + a.p + a.p*b)   = ++(a.p + b + a.p*b) { mulSRight(a.p, b) }
  => ++((a.p + a.p*b) + b) = ++(a.p + b + a.p*b) { addCommutative(b, a.p + a.p*b) }
  => ++(a.p + a.p*b + b)   = ++(a.p + b + a.p*b) { addAssociative(a.p, a.p*b, b) }
  => ++(a.p + a.p*b + b)   = ++(a.p + a.p*b + b) { addCommutative(b, a.p*b) }}}
;; print(mulSRight);

mulCommutative :: (a,b: Natp) -> a*b = b*a
{fork a
 {1 : rewrite mul1(b),
  ++: 
  => b + a.p*b = b * ++(a.p)
  => b + a.p*b = b + b*a.p { mulSRight(b, a.p) }
  => b + a.p*b = b + a.p*b { <- mulCommutative(a.p, b) }}}

;; todo this really should be built-in
successorIsDifferent :: (a: Natp, P: ++(a) = a) -> False
#norm(P)
{
 fork a
 {
  1:  P,
  ++: Q := destruct[0]P; successorIsDifferent(a.p, Q),
  }
 }

;; todo this really should be built-in
differentFromTwoSuccessor :: (a: Natp, P: ++(++(a)) = a) -> False
#norm(P)
{
 fork a
 {
  1:  P,
  ++: Q := destruct[0](P); differentFromTwoSuccessor(a.p, Q),
  }
 }

> :: fn(a, b: Natp) -> Bool
{fork a
 {1 : false,
  ++: fork b {1: true, ++: a.p > b.p}}}

successorIsLarger :: (a: Natp) -> ++(a) > a = true
{fork a
 {1 : ,
  ++: successorIsLarger(a.p)}}

gtAntiReflexive :: (a: Natp, p: a>a = true) -> False
#norm(p)
{fork a
 {1:  p,
  ++: gtAntiReflexive(a.p, p)}}

gtTransitive :: (a,b,c: Natp, P: a>b = true, Q: b>c = true) -> a>c = true
#norm(P,Q)
{
 fork a {
         1  P,
         ++ fork b {1 fork Q {},
                    ++ fork c {1, ++ gtTransitive(a.p,b.p,c.p, P, Q)}},
         }
 }

addIncreases :: (a,b: Natp) -> a+b > a = true
{
 fork a {1, ++ addIncreases(a.p, b)}
 }

addDifferent :: (a,b: Natp, p: a+b = a) -> False
#norm(p)
{
 lem1: a + b > a = true := addIncreases(a,b);
 lem2: a > a = true     := seq {=> a + b > a = true {<- p}; lem1};
 gtAntiReflexive(a, lem2);
 }

sumCancellation :: (a,b,c: Natp, p: a + b = a + c) -> (b = c)
#norm(p)
{
 fork a {
         1 destruct[0](p),
         ++ p := destruct[0](p); sumCancellation(a.p,b,c, p)}
 }

=? :: fn(a,b: Natp) -> Bool
{
 fork a
 {
  1 fork b {1 true, ++ false},
  ++ fork b {1 false, ++ a.p =? b.p}
  }
 }

add1DifferentFromAddS :: (a,b: Natp) -> a + 1 =? a + ++(b) = false
{
 fork a
 {
  1,
  ++ add1DifferentFromAddS(a.p, b);
  }
 }

eqSymmetric :: (a,b: Natp, p: a=?b = true) -> (b=?a = true)
#norm(p)
{
 fork a
 {
  1 fork b {1, ++ p},
  ++ fork b {1 p, ++ eqSymmetric(a.p, b.p, p)}
  }
 }

sumCancellation :: (a,b,c: Natp, p: a+b =? a+c = true) -> (b =? c = true)
#norm(p)
{
 fork a {
         1 p,
         ++ fork b {1 fork c {1, ++ trueNotFalse(a.p + 1 =? a.p + ++(c.p),
                                                 p,
                                                 add1DifferentFromAddS(a.p, c.p))},
                    ++ fork c
                    {1 lem1 := eqSymmetric(a.p + ++(b.p), a.p + 1, p);
                     lem2 := add1DifferentFromAddS(a.p, b.p);
                     trueNotFalse(a.p + 1 =? a.p + ++(b.p), lem1, lem2)
                     ,
                     ++
                     lem1 : ++(b.p) + a.p =? ++(c.p) + a.p = true :=
                     seq {=> a.p + ++(b.p) =? ++(c.p) + a.p = true {addCommutative}
                          => a.p + ++(b.p) =? a.p + ++(c.p) = true {addCommutative}
                          p
                          };
                     norm lem1;
                     lem2: a.p + b.p =? a.p + c.p = true :=
                     seq {
                          => b.p + a.p =? a.p + c.p = true {addCommutative}
                          => b.p + a.p =? c.p + a.p = true {addCommutative}
                          lem1;
                          };
                     sumCancellation(a.p,b.p,c.p, lem2)
                     }}}
 }

eqCorrect :: (a,b: Natp, p: a =? b = true) -> a = b
#norm(p)
{
 fork a
 {
  1  fork b {1  , ++ p},
  ++ fork b {1 p, ++ rewrite eqCorrect(a.p, b.p, p)}
  }
 }

addIsDifferent :: (a,b: Natp) -> a+b =? a = false
{fork a {1, ++ addIsDifferent(a.p, b)}}

addIsDifferent :: (a,b: Natp) -> a =? a+b = false
{fork a {1, ++ addIsDifferent(a.p,b)}}

eqReflexive :: (a: Natp) -> a =? a = true
{
 fork a
 {
  1,
  ++ eqReflexive(a.p),
  }
 }

addPreservesGt :: (a,b,c: Natp, p: a>b=true) -> a+c > b+c = true
#norm(p)
{
 fork a
 {
  1 fork p {},
  ++ fork b {1 rewrite addCommutative(a.p, c); addIncreases(c, a.p),
             ++ addPreservesGt(a.p,b.p,c, p)},
  }
 }

totalOrder :: (a,b: Natp) -> union {
                                    eq(p: a = b),
                                    gt(p: a > b = true),
                                    lt(p: b > a = true),
                                    }
{
 fork a
 {
  1 fork b {1 ctor[0](_), ++ ctor[2](_)},
  ++ fork b
  {
   1 ctor[1](_),
   ++ ind := totalOrder(a.p, b.p);
   fork ind {eq lem := ind.p; ctor[0](seq{rewrite lem}),
             gt ctor[1](ind.p),
             lt ctor[2](ind.p)} 
   }
  }
 }

