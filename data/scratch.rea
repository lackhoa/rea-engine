theorem andCommutative(a: Bool, b: Bool, c: Bool)
: (a & b) & c = a & (b & c)
{
 switch a.
 -
 ;; program should print b & c = b & c
 ;; expression state: switch a { | T { !:(b & c = b & c) } | F { ? }}
 reflexivity. ;; expression state: switch a { | T { reflexive(b & c) } | F { ? }}
 -
 ;; program should print F = F
 ;; expression state: switch a { | T { reflexive(b & c) } | F { ! }}
 reflexivity.
 ;; expression state: switch a { | T { reflexivity(b & c) } | F { reflexivity(F) }}
 }

print(andCommutative)







typedef Nat
{
 | 0
 | +1(Nat)
 }

define +(a: Nat, b: Nat) : Nat
{
 switch a
 {
  | 0
  { return b }

  | succ a'
  { return succ(a' + b) }
  }
 }

define 1: Nat { succ(0) }
define 2: Nat { succ(1) }
define 3: Nat { succ(2) }
define 1plus2 : (1 + 2 = 3)
{ return reduce(+) }
