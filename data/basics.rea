#load "boolean.rea"

check True: Set;
print identical;
print_raw (x: False) -> (x = x);
print_raw false & true | true & false | true;

print_raw &(true, |(false,true,),);
print_raw false & true | true & false | true;

print_raw identical(_, true, false);

check truth : false & true | true = true;
check truth : (fork true {true: &, false: |})(true, false) = false;

testAbstraction :: (a, b: Bool) -> Bool
{
 fork a
 {
  true : b,
  false: fork b {false: a, true: false},
  }
 }
print testAbstraction;

andWithFalse :: (a: Bool) -> (a & false = false)
{
 fork a
 {
  false: truth,
  true: truth,
  }
 }

andCommutative :: (a, b, c: Bool) -> (a & (b & c) = (a & b) & c)
{
 fork a
 {
  false:
  rewrite false & (b & c) => false;
  rewrite (false & b) => false;
  rewrite (false & c) => false;
  truth,

  true :
  rewrite true & (b & c) => b & c;
  rewrite (true & b) => b;
  truth,
  }
 }
print andCommutative;
print andCommutative(true, false, true);
check andCommutative(true, false, true) : (true & (false & true) = (true & false) & true);

dependentTypeTest :: (T: Type, A: T, a: A) -> (a = a)
{
 truth
 }
print dependentTypeTest;
print dependentTypeTest(Set, Bool, true);
