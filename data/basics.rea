#load "boolean.rea"
#load "nat.rea"

check True: Set;
;; print_raw (x: False) -> (x = x);
;; print_raw false & true | true & false | true;

;; print_raw &(true, |(false,true,),);
;; print_raw false & true | true & false | true;

;; print_raw =(_, true, false);

check_truth false & true | true = true;

testAbstraction :: fn (a, b: Bool) -> Bool
{fork a
 {true : b,
  false: fork b {false: a, true: false}}}

check andAssociative(true, false, true) : ((true & false) & true = true & false & true);

dependentTypeTest :: fn (T: Type, A: T, a: A) -> (a = a)
{_}
check dependentTypeTest(Set, Bool, true): (true = true);

testComplexFork :: fn (a, b: Nat) -> Nat
{fork a+b
 {0 : 0,
  ++: (a+b).p}}
check_truth testComplexFork(0, 0) = 0;
check_truth testComplexFork(1, 1) = 1;

testLocalVariable :: fn (x: Nat) -> Nat
{a := 3;
 b := 2;
 a + x + b}
check_truth testLocalVariable(1) = 6;

#should_fail
reproLet :: fn (a: Nat) -> Nat {b : Bool := true; b}
#should_fail off

#should_fail 
testCurryingWeird :: fn (a: Nat) -> (b, c: Nat) -> (a+b)+c = a+(b+c)
{fork a
 {++:
  ;; NOTE: the "a.p" is the weird part, which depends on rewrite rule to work,
  ;; and we need to support it.
  out : (b',c': Nat) -> (a.p+b')+c' = a.p+b'+c' := _ => { addAssociative(a.p, b', c') }
  out,

  0:
  out : (b, c: Nat) -> (a+b)+c = a+b+c := _ => { addAssociative(a, b, c) }
  out}}
#should_fail off

testCurrying2 :: fn (a, b, c: Nat) -> (a+b)+c = a+(b+c)
{fun : (b',c': Nat) -> (a+b')+c' = a+(b'+c') := _ => { addAssociative(a, b', c') }
 fun(b,c)}

#should_fail
testCurrying2Fail :: fn (a, b, c: Nat) -> (a+b)+c = a+(b+c)
{fun : (c',b': Nat) -> (a+b')+c' = a+(b'+c') := _ => { addAssociative(a, b', c') }
 fun(b,c)}
#should_fail off

testLocalFunction :: fn (a: Nat) -> Nat
{b := 3;
 f : (n: Nat) -> Nat := _ => { n*b }
 fork a {0: 4, ++: f(a)}}
check_truth testLocalFunction(2) = 6;

check_truth ((a,b: Nat) -> a+b = b+a) = ((A,B: Nat) -> A+B = B+A);
#should_fail
check_truth ((a,b: Nat) -> a+b = b+a) = ((A,B: Nat) -> A+B = B+B);
#should_fail off

testArrowEvaluation :: fn (A: Type) -> (a: A) -> A
{_ => {a}}

testComputationAsExpression :: fn (b: Bool) -> false = false & b {_}
