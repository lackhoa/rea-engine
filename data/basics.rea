#load "boolean.rea"
#load "nat.rea"

check True: Set;
;; print_raw (x: False) -> (x = x);
;; print_raw false & true | true & false | true;

;; print_raw &(true, |(false,true,),);
;; print_raw false & true | true & false | true;

;; print_raw =(_, true, false);

typecheck :: fn (id: (A: Set, a: A) -> a=a, b: Bool) -> b=b
{id(Bool, b)}

#should_fail
typecheck1 :: fn (id: (A: Set, a: A) -> a=a, b: Bool) -> b=b
{b}
typecheck2 :: fn (id: (A: Set, a: A) -> a=a, a,b: Bool) -> b=b
{id(Bool, a)}
#should_fail off

check_truth false & true = false;
check_truth false & true | true = true;

testAbstraction :: fn (a, b: Bool) -> Bool
{fork a
 {true : b,
  false: fork b {false: a, true: false}}}

check andAssociative(true, false, true) : ((true & false) & true = true & false & true);

#should_fail
dependentTypeFailTest :: fn (T: Type, A: T, a: A) -> a=a
{_}
#should_fail off

dependentTypeTest :: fn (A: Set, a: A) -> a=a
{_}
check dependentTypeTest(Bool, true): true=true;

testComplexFork :: fn (a, b: Nat) -> Nat
{apb := a+b;
 fork apb
 {0 : 0,
  ++: apb.p}}
check_truth testComplexFork(0, 0) = 0;
check_truth testComplexFork(1, 1) = 1;

testLocalVariable :: fn (x: Nat) -> Nat
{a := 3;
 b := 2;
 a + x + b}
check_truth testLocalVariable(1) = 6;

#should_fail
reproLet :: fn (a: Nat) -> Nat {b : Bool := true; b}
#should_fail off

#should_fail 
testCurryingWeird :: fn (a: Nat) -> (b, c: Nat) -> (a+b)+c = a+(b+c)
{fork a
 {++:
  ;; NOTE: the "a.p" is the weird part, which depends on rewrite rule to work,
  ;; and we need to support it.
  out : (b',c': Nat) -> (a.p+b')+c' = a.p+b'+c' := _ => { addAssociative(a.p, b', c') }
  out,

  0:
  out : (b, c: Nat) -> (a+b)+c = a+b+c := _ => { addAssociative(a, b, c) }
  out}}
#should_fail off

testCurrying2 :: fn (a, b, c: Nat) -> (a+b)+c = a+(b+c)
{fun : (b',c': Nat) -> (a+b')+c' = a+(b'+c') := _ => { addAssociative(a, b', c') }
 fun(b,c)}

#should_fail
testCurrying2Fail :: fn (a, b, c: Nat) -> (a+b)+c = a+(b+c)
{fun : (c',b': Nat) -> (a+b')+c' = a+(b'+c') := _ => { addAssociative(a, b', c') }
 fun(b,c)}
#should_fail off

testLocalFunction :: fn (a: Nat) -> Nat
{b := 3;
 f : (n: Nat) -> Nat := _ => { n*b }
 fork a {0: 4, ++: f(a)}}
check_truth testLocalFunction(2) = 6;

#should_fail
check_truth ((a,b: Nat) -> a+b = b+a) = ((A,B: Nat) -> A+B = B+A);
check_truth ((a,b: Nat) -> a+b = b+a) = ((A,B: Nat) -> A+B = B+B);
#should_fail off

testArrowEvaluation :: fn (A: Type) -> (a: A) -> A {_ => {a}}

testComputationAsExpression :: fn (b: Bool) -> false = false & b {_}

testFunctionPointer :: fn (a,b: Bool) -> Bool
{foo : (x: Bool) -> Bool := _ => {x & b}
 d := false;
 foo(a);}
check_truth testFunctionPointer(true,true) = true;

testFunctionPointerHelper :: fn () -> (a,b,c: Bool) -> Bool {_ => {c}}
testFunctionPointerMore :: fn (a: Bool) -> Bool
{foo := testFunctionPointerHelper();
 foo(true,false,a);}
check_truth testFunctionPointerMore(false) = false;

testConstantInFunctionHelper :: fn () -> Nat {a := 4; a}
testConstantInFunction :: fn () -> Nat {b := testConstantInFunctionHelper(); b}
check_truth testConstantInFunction() = 4;

;; showing off now that we have arrow type normalization
multiplyPosv2 :: (a,b: Nat, a_positive: a != 0, b_positive: b != 0) -> a*b != 0
{norm a_positive; norm b_positive;
 fork a
 {0 : _ => {a_positive(_)},
  ++: ;; goal: (E: b + a.p * b = 0) -> False
  _ => {fork b {0: b_positive(_), ++: norm E; E}}
  }}

;; todo: ridiculous that we can't normalize without a function
oneIsNotZero :: () -> 1 != 0 {norm; _ => {E}}
test_eval multiplyPos(1,1,oneIsNotZero(),oneIsNotZero());
;; print multiplyPos;

somethingWicked :: fn (a,b,c: Nat) -> Type {(p: a=b) -> (q: b=c) -> a=c}
somethingWickedUsage :: () -> (x,y,z: Nat) -> (somethingWicked(x,y,z))
{norm;
 _ => {_ => {_ => {rewrite p; rewrite q}}}}

StructWithFunction :: union {makeStructWithFunction: (a: Nat, b: (E: a=0) -> False)}
oneEqualZeroImpliesFalse :: fn () -> ((E: 1=0) -> False) {norm; _ => {E}}
testFunctionInComposite :: fn (x: StructWithFunction, E: x.a = 0) -> False {norm; x.b(E)}
testFunctionInCompositeUsage :: (Wrong: 1=0) -> False
{
 obj := testFunctionInComposite(makeStructWithFunction(1, oneEqualZeroImpliesFalse()), Wrong);
 obj
 }
;; print testFunctionInCompositeUsage;

;; todo important test arrow type unification by using this "arrowTypeUnification" to do things
;; arrowTypeUnification :: (x: True) -> (a: True) -> a=x {_ => {fork a {truth: fork x {truth: }}}}
