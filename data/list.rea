;; ----
;; List (Lists that can be empty)
;; ----

List :: union($$ListType: Type)
{nil,
 cons(head: ListType, tail: List(ListType))}

+ :: fn($T: Type, l,m: List(T)) -> List(T)
{fork l
 {nil  return m,
  cons return l.head cons (l.tail + m)}}

nonEmpty :: fn ($A: Type, list: List(A)) -> Type
#expand
{return list != nil(A)}

concatNonEmpty :: (T:Type, l,m: List(T), nonEmpty(l), nonEmpty(m)) -> nonEmpty(l+m)
#hint
{fork l {nil, cons}}

Permute :: union($$T: Type, List(T), List(T))
{
 permuteNil() -> Permute(nil(T), nil(T))
 ,
 permuteSkip(a: T, l,l1: List(T), Permute(l, l1)) -> Permute(a cons l, a cons l1)
 ,
 permuteSwap(a,b: T, l: List(T)) -> Permute(a cons b cons l, b cons a cons l)
 ,
 permuteChain(l,l1,l2: List(T), Permute(l, l1), Permute(l1, l2)) -> Permute(l, l2)
 }

binaryOp :: fn(T: Type) -> Type
#expand
{return (a,b: T) -> T}

isAssociative :: fn($T: Type, op: binaryOp(T)) -> Type
#expand
{return (a,b,c: T) -> (a op b) op c = a op b op c}

fold :: fn($A: Type, op: binaryOp(A), a: A, tail: List(A)) -> A
#no_print_as_binop
{fork tail
 {nil return a,
  cons
  return a op fold(op, tail.head, tail.tail)}}

foldConcat :: (($T: Type, op: binaryOp(T), assoc: isAssociative(op),
                a,b: T, l,m: List(T))
               -> (fold(op, a, l+(b cons m)) =
                   fold(op, a, l) op fold(op, b, m)))
#hint
{fork l
 {nil,
  cons
  => a op fold(op, l.head, l.tail + (b cons m)) = a op fold(op, l.head, l.tail) op fold(op, b, m) {assoc}
  => a op fold(op, l.head, l.tail) op fold(op, b, m) = a op fold(op, l.head, l.tail) op fold(op, b, m) {foldConcat}
  }}

foldPermute :: ($T: Type,
                op: (a,b: T) -> T,
                associative: (a,b,c: T) -> (a op b) op c = a op b op c,
                commutative: (a,b: T) -> a op b = b op a,
                a,b: T, l,m: List(T),
                p: Permute(a cons l, b cons m)) -> fold(op, a, l) = fold(op, b, m)
{
 fork p
 {
  permuteNil
  i := invert(p);
  ;; reductio;
  ,
  permuteSkip
  ,
  permuteSwap
  ,
  permuteChain
  }
 }
