;; ----
;; List 
;; ----

List :: union(ListType: Type)
{single(head: ListType),
 cons  (head: ListType, tail: List(ListType))}

fold :: fn($A: Type, op: (a,b: A) -> A, list: List(A)) -> A
#no_print_as_binop
{fork list
 {single
  return list.head,

  cons
  return list.head op fold(op, list.tail)
  }
 }


+ :: fn($T: Type, l,m: List(T)) -> List(T)
{fork l
 {single return l.head cons m,
  cons   return l.head cons (l.tail + m)}}

Permutation :: union($A: Type, abc,cab: List(A))
{
 samePermutation(same: abc=cab),
 permutation(a: A, bc,c,b: List(A),
             abc_destruct: abc=(a cons bc),
             cab_destruct: cab=(c + (a cons b)),
             recurse: Permutation(bc, c+b))
 }

foldConcat :: ($A: Type, op: (a,b: A) -> A,
               associative: (a,b,c: A) -> (a op b) op c = a op b op c,
               l,m: List(A)) -> (fold(op, l+m) = fold(op, l) op fold(op, m))
#hint
{fork l
 {single,
  cons
  rewrite foldConcat(op, associative, l.tail, m);
  ;; (l.head op fold(op, l.tail) op fold(op, m)) = ((l.head op fold(op, l.tail)) op fold(op, m))
  rewrite associative(l.head, fold(op, l.tail), fold(op, m));
  }}

foldPermutation :: ($A: Type,
                    op: (a,b: A) -> A,
                    op_associative: (a,b,c: A) -> (a op b) op c = a op b op c,
                    op_commutative: (a,b: A) -> a op b = b op a,
                    l,m: List(A),
                    p: Permutation(l, m)) -> fold(op, l) = fold(op, m)
{
 fork p
 {
  samePermutation
  rewrite p.same,

  permutation
  rewrite p.abc_destruct;
  rewrite p.cab_destruct;
  norm;
  ;; p.a op fold(op, p.bc) = fold(op, p.c + (p.a cons p.b))
  => p.a op fold(op, p.bc) = fold(op, p.c) op fold(op, p.a cons p.b)
  => p.a op fold(op, p.bc) = fold(op, p.c) op p.a op fold(op, p.b)
  => p.a op fold(op, p.bc) = (p.a op fold(op, p.b)) op fold(op, p.c) {op_commutative}
  => p.a op fold(op, p.bc) = p.a op fold(op, p.b) op fold(op, p.c) {op_associative}
  => p.a op fold(op, p.bc) = p.a op fold(op, p.c) op fold(op, p.b) {op_commutative}
  => p.a op fold(op, p.bc) = p.a op fold(op, p.c + p.b);
  prove fold(op, p.bc) = fold(op, p.c + p.b) {return foldPermutation(...)} as e
  rewrite e;
  }
 }
