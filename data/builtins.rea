;; ----
;; List 
;; ----

List :: union(ListType: Type)
{single(head: ListType),
 cons  (head: ListType, tail: List(ListType))}

fold :: fn($A: Type, op: (a,b: A) -> A, list: List(A)) -> A
#no_print_as_binop
{fork list
 {single
  return list.head,

  cons
  return list.head op fold(op, list.tail)
  }
 }

+ :: fn($T: Type, l,m: List(T)) -> List(T)
{fork l
 {single return l.head cons m,
  cons   return l.head cons (l.tail + m)}}

Permutation :: union($T: Type, abc,bac: List(T))
{
 permutationSame(same: abc=bac),
 permutation(a: T, bc,b,c: List(T),
             abc_destruct: abc=(a cons bc),
             bac_destruct: bac=(b + (a cons c)),
             recurse: Permutation(bc, b+c)),
 permutationLast(a: T, bc,b: List(T),
                 abc_destruct: abc=(a cons bc),
                 bac_destruct: bac=(b + single(a)),
                 recurse: Permutation(bc, b))
 }

foldConcat :: ($T: Type, op: (a,b: T) -> T,
               associative: (a,b,c: T) -> (a op b) op c = a op b op c,
               l,m: List(T)) -> (fold(op, l+m) = fold(op, l) op fold(op, m))
#hint
{fork l
 {single,
  cons
  rewrite foldConcat(op, associative, l.tail, m);
  ;; (l.head op fold(op, l.tail) op fold(op, m)) = ((l.head op fold(op, l.tail)) op fold(op, m))
  rewrite associative(l.head, fold(op, l.tail), fold(op, m));
  }}

foldPermutation :: ($T: Type,
                    op: (a,b: T) -> T,
                    op_associative: (a,b,c: T) -> (a op b) op c = a op b op c,
                    op_commutative: (a,b: T) -> a op b = b op a,
                    l,m: List(T),
                    p: Permutation(l, m)) -> fold(op, l) = fold(op, m)
{
 fork p
 {
  permutationSame
  rewrite p.same,

  permutationLast
  rewrite p.abc_destruct;
  rewrite p.bac_destruct;
  norm;
  ;; p.a op fold(op, p.bc) = fold(op, p.b + single(p.a))
  => p.a op fold(op, p.bc) = fold(op, p.b) op fold(op, single(p.a));
  norm;
  => p.a op fold(op, p.bc) = p.a op fold(op, p.b) {op_commutative};
  prove fold(op, p.bc) = fold(op, p.b) {return foldPermutation(...)} as e
  rewrite e;
  ,

  permutation
  rewrite p.abc_destruct;
  rewrite p.bac_destruct;
  norm;
  ;; p.a op fold(op, p.bc) = fold(op, p.b + (p.a cons p.c))
  => p.a op fold(op, p.bc) = fold(op, p.b) op fold(op, p.a cons p.c)
  => p.a op fold(op, p.bc) = fold(op, p.b) op p.a op fold(op, p.c)
  => p.a op fold(op, p.bc) = (p.a op fold(op, p.c)) op fold(op, p.b) {op_commutative}
  => p.a op fold(op, p.bc) = p.a op fold(op, p.c) op fold(op, p.b) {op_associative}
  => p.a op fold(op, p.bc) = p.a op fold(op, p.b) op fold(op, p.c) {op_commutative}
  => p.a op fold(op, p.bc) = p.a op fold(op, p.b + p.c);
  prove fold(op, p.bc) = fold(op, p.b + p.c) {return foldPermutation(...)} as e
  rewrite e;
  }
 }

;; #debug bookmark
;; helper :: fn(T: Type, a,b,c: List(T), p: Permutation(a,b), e: b=c) -> Permutation(a,c)
;; {
;;  rewrite <- e;
;;  }
