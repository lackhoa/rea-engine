Bool :: union {false, true}

& :: fn (a, b: Bool) -> Bool
{
 fork a
 {
  false: false,
  true:  b
  }
 }

| :: fn (a, b: Bool) -> Bool
{
 fork a
 {
  true:  true,
  false: b,
  }
 }

check refl(true): true = true;

andAssociative :: fn (a, b, c: Bool) -> ((a & b) & c = a & b & c)
{fork a
 {false: computation,
  true : computation}}

andFalse :: (a: Bool) -> a & false = false {fork a {false:, true:}}
