Bool :: union {false, true}

& :: fn (a,b: Bool) -> Bool
{fork a
 {false: false,
  true:  b}}

| :: fn (a, b: Bool) -> Bool
{fork a
 {true:  true,
  false: b}}

andAssociative :: (a,b,c: Bool) -> (a&b)&c = a&b&c
{fork a {false, true}}

andFalse :: (a: Bool) -> a & false = false
{fork a {false, true}}

andTrue :: (a: Bool) -> a & true = a
{fork a {false, true}}

andCommutative :: (a,b: Bool) -> a & b = b & a
{fork a {false rewrite andFalse(b),
         true  rewrite andTrue(b)}}

;; todo #automate
trueNotFalse :: (a: Bool, p: a=true, q: a=false) -> False
{
 => true = false;
 rewrite <- p;
 rewrite <- q;
 }
