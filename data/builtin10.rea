eqChain :: fn($A: Type, $a,$b,$c: A, a=b, b=c) -> a=c {=> b = c {seek(a=b)} seek}
falseImpliesAll :: fn(f: False, G: Type) -> G {fork f {}}
primitive Array : (A: Type) -> Type;
primitive Int : Type;

;; -----
;; Utils
;; -----

!= :: fn ($A: Type, a,b: A) -> Type
#expand
{ return (a=b) -> False }

identity :: fn(A: Type) -> (a: A) -> A
{ return fn {return a} }

alreadyGotFalse :: (A: Type, e: A=False) -> ((A) -> False)
#hint
{ return fn (a:A) -> False { rewrite <- e; return a } }

Maybe :: union($$A: Type)
{none,
 some(v: A)}
