#load "nat.rea"

slice :: ($A: Type, l: Array(A), a,b: Int) -> A

fold :: ($A: Type, a: A, l: Array(A)) -> A
{
 fork length(l)
 {
  0  return a
  ++ return a + fold(l.[0], slice(l, 1, length(l)))
  }
 }

Permute :: union(Array, Array)
{
 permuteSame(l) -> Permute(l, l)
 ,
 permuteSwap(l: Array, a,b: Nat) -> Permute(l, swap(l, a,b))
 ,
 permuteChain(l,l1,l2: List(T), Permute(l, l1), Permute(l1, l2)) -> Permute(l, l2)
 }

foldPermute :: ($A: Type, a,a1: A, l,l1: Array, p: Permute(a cons l, a1 cons l1)) -> fold(a,l) = fold(a1,l1)
{
 fork p
 {
  permuteSame
  ;; trivial yo!
  ,
  permuteSwap
  ,
  permuteChain
  }
 }
