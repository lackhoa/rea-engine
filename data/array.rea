fold :: (a: Nat, l: Array) -> Nat
{
 fork length(l)
 {
  0  a
  ++ a + fold(l[0], slice(l, 1, length(l)))
  }
 }

Permute :: union(Array, Array)
{
 permuteSame(l) -> Permute(l, l)
 ,
 permuteSwap(l: Array, a,b: Nat) -> Permute(l, swap(l, a,b))
 ,
 permuteChain(l,l1,l2: List(T), Permute(l, l1), Permute(l1, l2)) -> Permute(l, l2)
 }

foldPermute :: (a,a1: Nat, l,l1: Array, p: Permute(a cons l, a1 cons l1)) -> fold(a,l) = fold(a1,l1)
{
 fork p
 {
  permuteSame
  ;; trivial yo!
  ,
  permuteSwap
  ;; a1 cons l1 = swap(a cons l, a,b)
  ,
  permuteChain
  }
 }
