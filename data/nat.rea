#load "boolean.rea"

Nat :: union
{0,
 ++: (p: Nat) -> Nat}

+ :: fn (n, m: Nat) -> Nat
{fork n
 {0  : m,
  ++ : ++(n.p + m)}}

1 := ++(0);
2 := ++(1);
3 := ++(2);
4 := ++(3);
5 := ++(4);
6 := ++(5);
check_truth 1 + 2 = 3;

pred :: fn (n : Nat) -> Nat
{fork n
 {0  : 0,
  ++ : n.p}}
check_truth pred(4) = 3;

even :: fn (n : Nat) -> Bool
{fork n
 {0  : true,
  ++ : fork n.p {0 : false, ++ : even(n.p.p)}}}

check_truth even(4) = true;
check_truth even(3) = false;

* :: fn (a, b: Nat) -> Nat
{fork a
 {0  : 0,
  ++ : b + a.p * b}}

check_truth  2*3 = 6;

- :: fn (n, m : Nat) -> Nat
{fork n
 {0  : 0,
  ++ : fork(m) {0 : n, ++(m1) : n.p - m.p}}}

check_truth 3 - 2 = 1;
check_truth 4 - 1 = 3;

add0Right :: (n: Nat) -> n + 0 = n
{fork n
 {0 :,
  ++: => ++(n.p) = ++(n.p) {add0Right}}}

addSRight :: (n, m: Nat) -> n + ++(m) = ++(n+m)
{fork n
 {0 : ,
  ++: => ++(++(n.p + m)) = ++(++(n.p + m)) {addSRight}}}

addCommutative :: (n, m: Nat) -> (n+m = m+n)
{fork n
 {0 : => m = m {add0Right},
  ++:
  => ++(m + n.p) = m + ++(n.p) {addCommutative}
  => ++(m + n.p) = ++(m + n.p) {addSRight}}}

addAssociative :: (a, b, c: Nat) -> (a+b)+c = a+b+c
{fork a
 {0 : ,
  ++:
  => ++(a.p + b + c) = ++(a.p + b + c) {addAssociative}}}
;; print(addAssociative(0, 0*0, 0*0));

mulDistributive :: (a,b,c: Nat) -> a*c+b*c = (a+b)*c
{fork a
 {0: refl(b*c),
  ++:
  => c + a.p*c + b*c = c + (a.p+b)*c {addAssociative(c, (a.p * c), (b * c))}
  => c + (a.p+b)*c   = c + (a.p+b)*c {mulDistributive(a.p, b, c)}}}
;; print(mulDistributive(1+1,0,0));

mulAssociative :: (a,b,c: Nat) -> (a*b)*c = a*b*c
{fork a
 {0: ,
  ++:
  => (b + a.p*b)*c  = b*c + (a.p*b)*c {<- mulAssociative(a.p, b, c)}
  => (b + a.p*b)*c  = (b + a.p*b)*c {mulDistributive(b, a.p*b, c)}}}
;; print(mulAssociative(1,0,0));

!= :: fn (_A: Set, a, b: _A) -> Type
{ (E: a = b) -> False }

testFillingHole :: (a: Nat, a_positive: a != 0, P: a=0) -> False
{norm a_positive;
 fork (a)
 {0 : a_positive(_),  ;; since a is now 0, we can fill this hole.
  ++: P}}

multiplyPos :: (a,b: Nat, a_positive: a != 0, b_positive: b != 0) -> a*b != 0
{norm a_positive; norm b_positive;
 norm;
 _ => {fork a
       {0: a_positive(_),
        ++: fork b {0: b_positive(_), ++: E}}}}

;; showing off now that we have arrow type normalization
multiplyPosv2 :: (a,b: Nat, a_positive: a != 0, b_positive: b != 0) -> a*b != 0
{norm a_positive; norm b_positive;
 fork a
 {0 : _ => {a_positive(_)},
  ++: ;; (E: b + a.p * b = 0) -> False
  _ => {fork b {0: b_positive(_), ++: E}}}}
