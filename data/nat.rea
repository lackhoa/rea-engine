#load "boolean.rea"
#load "utils.rea"

Nat :: union
{0,
 ++(p: Nat)}

+ :: fn (n, m: Nat) -> Nat
{fork n
 {0  : m,
  ++ : ++(n.p + m)}}

1 := ++(0);
2 := ++(1);
3 := ++(2);
4 := ++(3);
5 := ++(4);
6 := ++(5);
check_truth 1 + 2 = 3;

pred :: fn (n : Nat) -> Nat
{fork n
 {0  : 0,
  ++ : n.p}}
check_truth pred(4) = 3;

even :: fn (n : Nat) -> Bool
{fork n
 {0  : true,
  ++ : fork n.p {0 : false, ++ : even(n.p.p)}}}

check_truth even(4) = true;
check_truth even(3) = false;

* :: fn (a, b: Nat) -> Nat
{fork a
 {0  : 0,
  ++ : b + a.p * b}}

check_truth  2*3 = 6;

- :: fn (n, m : Nat) -> Nat
{fork n
 {0  : 0,
  ++ : fork(m) {0 : n, ++ : n.p - m.p}}}

check_truth 3 - 2 = 1;
check_truth 4 - 1 = 3;

add0 :: (n: Nat) -> n + 0 = n
{fork n
 {0 :,
  ++:
  => ++(n.p) = ++(n.p) {add0}
  }}

addSRight :: (n, m: Nat) -> n + ++(m) = ++(n+m)
{fork n
 {0 : ,
  ++: => ++(++(n.p + m)) = ++(++(n.p + m)) {addSRight}}}

addCommutative :: (m,n: Nat) -> (n+m = m+n)
{fork n
 {0 : => m = m {add0},
  ++:
  => ++(m + n.p) = m + ++(n.p) {addCommutative}
  => ++(m + n.p) = ++(m + n.p) {addSRight}}}

addAssociative :: (a,b,c: Nat) -> (a+b)+c = a+b+c
{fork a
 {0 : ,
  ++:
  rewrite addAssociative(a.p,b,c)}}

mulDistributive :: (a,b,c: Nat) -> a*c+b*c = (a+b)*c
{fork a
 {0:,
  ++:
  => c + a.p*c + b*c = c + (a.p+b)*c {addAssociative(c, (a.p * c), (b * c))}
  => c + (a.p+b)*c   = c + (a.p+b)*c {mulDistributive(a.p, b, c)}}}
test_eval mulDistributive(1+1,0,0);

mulAssociative :: (a,b,c: Nat) -> (a*b)*c = a*b*c
{fork a
 {0: ,
  ++:
  => (b + a.p*b)*c  = b*c + (a.p*b)*c {<- mulAssociative(a.p, b, c)}
  => (b + a.p*b)*c  = (b + a.p*b)*c {mulDistributive(b, a.p*b, c)}}}
test_eval mulAssociative(1,0,0);
;; print mulAssociative(1,0,0);

addPos :: (a,b: Nat, apos: a!=0) -> a+b != 0
{norm;
 _ => {fork a {0 norm apos; apos(_),
               ++
               norm(seek(a+b = 0));
               seek(False)
               }}}

mulPos :: (a,b: Nat, apos: a!=0, bpos: b!=0) -> a*b != 0
{norm apos; norm bpos; norm;
 _ => {fork a {0: apos(_),
               ++: fork b {0: bpos(_),
                           ++: norm seek(a * b = 0); seek(False)}}}}

mul0 :: (a: Nat) -> a * 0 = 0
{
 fork a
 {
  0: ,
  ++: rewrite mul0(a.p),
  }
 }


mulSRight :: (a,b: Nat) -> a * ++(b) = a + a*b
{fork a
 {0:,
  ++:
  => ++(b + a.p * ++(b))   = ++(a.p + b + a.p*b)
  => ++(b + a.p + a.p*b)   = ++(a.p + b + a.p*b) { mulSRight(a.p, b) }
  => ++((a.p + a.p*b) + b) = ++(a.p + b + a.p*b) { addCommutative }
  => ++(a.p + a.p*b + b)   = ++(a.p + b + a.p*b) { addAssociative(a.p, a.p*b, b) }
  => ++(a.p + a.p*b + b)   = ++(a.p + a.p*b + b) { addCommutative }}}

mulCommutative :: (a,b: Nat) -> a*b = b*a
{fork a
 {0 : rewrite mul0(b),
  ++: 
  => b + a.p*b = b * ++(a.p)
  => b + a.p*b = b + b*a.p { mulSRight(b, a.p) }
  => b + a.p*b = b + a.p*b { <- mulCommutative(a.p, b) }
  }}
