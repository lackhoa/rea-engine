#load "boolean.rea"

Nat :: union
{0,
 ++: struct {p: Nat}}

+ :: fn (n, m: Nat) -> Nat
{fork n
 {0  : m,
  ++ : ++(n.p + m)}}

1 := ++(0);
2 := ++(1);
3 := ++(2);
4 := ++(3);
5 := ++(4);
6 := ++(5);
check_truth 1 + 2 = 3;

pred :: fn (n : Nat) -> Nat
{fork n
 {0  : 0,
  ++ : n.p}}
check_truth pred(4) = 3;

even :: fn (n : Nat) -> Bool
{fork n
 {0  : true,
  ++ : fork n.p {0 : false, ++ : even(n.p.p)}}}

check_truth even(4) = true;
check_truth even(3) = false;

* :: fn (a, b: Nat) -> Nat
{fork a
 {0  : 0,
  ++ : b + a.p * b}}

check_truth  2*3 = 6;

- :: fn (n, m : Nat) -> Nat
{fork n
 {0  : 0,
  ++ : fork(m) {0 : n, ++ : n.p - m.p}}}

check_truth 3 - 2 = 1;
check_truth 4 - 1 = 3;

add0Right :: (n: Nat) -> n + 0 = n
{fork n
 {0 :,
  ++:
  => ++(n.p) = ++(n.p) {add0Right}
  }}

addSRight :: (n, m: Nat) -> n + ++(m) = ++(n+m)
{fork n
 {0 : ,
  ++: => ++(++(n.p + m)) = ++(++(n.p + m)) {addSRight}}}

addCommutative :: (n, m: Nat) -> (n+m = m+n)
{fork n
 {0 : => m = m {add0Right},
  ++:
  => ++(m + n.p) = m + ++(n.p) {addCommutative}
  => ++(m + n.p) = ++(m + n.p) {addSRight}}}

addAssociative :: (a, b, c: Nat) -> (a+b)+c = a+b+c
{fork a
 {0 : ,
  ++:
  rewrite addAssociative(a.p,b,c)}}

mulDistributive :: (a,b,c: Nat) -> a*c+b*c = (a+b)*c
{fork a
 {0:,
  ++:
  => c + a.p*c + b*c = c + (a.p+b)*c {addAssociative(c, (a.p * c), (b * c))}
  => c + (a.p+b)*c   = c + (a.p+b)*c {mulDistributive(a.p, b, c)}}}
test_eval mulDistributive(1+1,0,0);

mulAssociative :: (a,b,c: Nat) -> (a*b)*c = a*b*c
{fork a
 {0: ,
  ++:
  => (b + a.p*b)*c  = b*c + (a.p*b)*c {<- mulAssociative(a.p, b, c)}
  => (b + a.p*b)*c  = (b + a.p*b)*c {mulDistributive(b, a.p*b, c)}}}
test_eval mulAssociative(1,0,0);
print mulAssociative(1,0,0);

!= :: fn (_A: Set, a,b: _A) -> Type
{ (E: a=b) -> False }

testFillingHole :: (x: Nat, x_positive: x!=0, P: x=0) -> False
{norm x_positive;
 fork (x)
 {0 : norm x_positive; x_positive(_),
  ++: norm P; P}
 }

multiplyPos :: (a,b: Nat, a_positive: a != 0, b_positive: b != 0) -> a*b != 0
{norm b_positive; norm a_positive;
 norm;
 _ => {fork a {0: a_positive(_),
               ++: fork b {0: b_positive(_), ++: norm E; E}}}}
