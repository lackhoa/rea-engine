#load "boolean.rea"

Nat :: union
{
 0,
 s: (p: Nat) -> Nat,
 }

+ :: (n, m: Nat) -> Nat
{
 fork n
 {
  0     : m,
  s(n') : s(n.p + m),
  }
 }

1 := s(0);
2 := s(1);
3 := s(2);
4 := s(3);
5 := s(4);
6 := s(5);
check truth: 1 + 2 = 3;

pred :: (n : Nat) -> Nat
{
 fork n
 {
  0 : 0,
  s(n) : n
  }
 }

even :: (n : Nat) -> Bool
{
 fork n
 {
  0      : true,
  s(n69) : fork n69 {0 : false, s(n70) : even(n70)},
  }
 }

check truth: even(4) = true;
check truth: even(3) = false;

* :: (n, m: Nat) -> Nat
{
 fork n
 {
  0     : 0,
  s(n1) : m + n1 * m,
  }
 }

check truth: 2*3 = 6;

- :: (n, m : Nat) -> Nat
{
 fork n
 {
  0     : 0,
  s(n1) : fork(m) {0 : n, s(m1) : n1 - m1}
  }
 }

check truth: 3 - 2 = 1;
check truth: 4 - 1 = 3;

plusIdRight :: (n: Nat) -> n + 0 = n
{
 fork n
 {
  0      : truth,
  s(n69) : rewrite plusIdRight(n69); truth,
  }
 }

plusSRight :: (n, m: Nat) -> n + s(m) = s(n+m)
{
 fork n
 {
  0    : truth,
  s(n'): rewrite plusSRight(n', m); truth,
  }
 }

plusCommutative :: (n, m: Nat) -> (n + m = m + n)
{
 fork n
 {
  0    : rewrite plusIdRight(m); truth,
  s(n1): rewrite plusCommutative(n1, m); rewrite plusSRight(m, n1); truth,
  }
 }

plusAssociative :: (a, b, c: Nat) -> (a+b)+c = a+(b+c)
{
 fork a
 {
  0    : truth,
  s(a'): rewrite plusAssociative(a', b, c); truth,
  }
 }
