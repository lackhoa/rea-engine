#load "boolean.rea"

Nat :: union
{0,
 ++: (p: Nat) -> Nat}

+ :: fn (n, m: Nat) -> Nat
{fork n
 {0  : m,
  ++ : ++(n.p + m)}}

1 := ++(0);
2 := ++(1);
3 := ++(2);
4 := ++(3);
5 := ++(4);
6 := ++(5);
check_truth 1 + 2 = 3;

pred :: fn (n : Nat) -> Nat
{fork n
 {0  : 0,
  ++ : n.p}}
check_truth pred(4) = 3;

even :: fn (n : Nat) -> Bool
{fork n
 {0  : true,
  ++ : fork n.p {0 : false, ++ : even(n.p.p)}}}

check_truth even(4) = true;
check_truth even(3) = false;

* :: fn (n, m: Nat) -> Nat
{
 fork n
 {
  0  : 0,
  ++ : m + n.p * m,
  }
 }

check_truth  2*3 = 6;

- :: fn (n, m : Nat) -> Nat
{
 fork n
 {
  0  : 0,
  ++ : fork(m) {0 : n, ++(m1) : n.p - m.p}
  }
 }

check_truth 3 - 2 = 1;
check_truth 4 - 1 = 3;

addIdRight :: (n: Nat) -> n + 0 = n
{
 fork n
 {
  0 : truth,
  ++:
  rewrite addIdRight(n.p);
  truth;
  }
 }
;; print(addIdRight(2));

addSRight :: (n, m: Nat) -> n + ++(m) = ++(n+m)
{
 fork n
 {
  0 : truth,
  ++: rewrite addSRight(n.p, m); truth,
  }
 }

addCommutative :: fn (n, m: Nat) -> (n + m = m + n)
{
 fork n
 {
  0 : rewrite addIdRight(m); truth,
  ++: rewrite addCommutative(n.p, m); rewrite addSRight(m, n.p); truth,
  }
 }

addAssociative :: (a, b, c: Nat) -> (a+b)+c = a+b+c
{
 fork a
 {
  0 : truth,
  ++: rewrite addAssociative(a.p, b, c); truth,
  }
 }

mulDistributive :: (a,b,c: Nat) -> a*c+b*c = (a+b)*c
{fork a
 {0: truth,

  ++:
  rewrite mulDistributive(a.p, b, c);
  rewrite addAssociative(c, (a.p * c), (b * c));
  rewrite mulDistributive(a.p, b, c);
  truth}}
;; print(mulDistributive(1,2,3));

mulAssociative :: (a,b,c: Nat) -> (a*b)*c = a*b*c
{fork a
 {0: truth,
  ++:
  rewrite left mulDistributive(b, (a.p * b), c);
  rewrite mulAssociative(a.p, b, c);
  truth,
  }}

!= :: fn (_A: Set, a, b: _A) -> Type
{
 (E: a = b) -> False
 }

multiplyPos :: (a,b: Nat, a_positive: a != 0, b_positive: b != 0) -> a*b != 0
{
 ;; a_pos : (E: a = 0) -> False := a_positive
 ;; b_pos : (E: b = 0) -> False := b_positive
 out :: fn (e: a*b = 0) -> False
 {fork a
  {0:
   ;; a_pos(truth)
   a_positive(truth),

   ++:
   fork b
   {0:
    ;; b_pos(truth)
    b_positive(truth),
    ++: e
    }}}
 out
 }
