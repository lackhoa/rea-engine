#load "boolean.rea"

Nat :: union
{
 0,
 s: (p: Nat) -> Nat,
 }

+ :: (n, m: Nat) -> Nat
{
 fork n
 {
  0     : m,
  s(n') : s(n.p + m),
  }
 }

1 := s(0);
2 := s(1);
3 := s(2);
4 := s(3);
5 := s(4);
6 := s(5);
check truth: 1 + 2 = 3;

pred :: (n : Nat) -> Nat
{
 fork n
 {
  0 : 0,
  s(n) : n
  }
 }

even :: (n : Nat) -> Bool
{
 fork n
 {
  0      : true,
  s(n69) : fork n.p {0 : false, s(n70) : even(n.p.p)},
  }
 }

check truth: even(4) = true;
check truth: even(3) = false;

* :: (n, m: Nat) -> Nat
{
 fork n
 {
  0     : 0,
  s(n1) : m + n.p * m,
  }
 }

check truth: 2*3 = 6;

- :: (n, m : Nat) -> Nat
{
 fork n
 {
  0     : 0,
  s(n1) : fork(m) {0 : n, s(m1) : n.p - m.p}
  }
 }

check truth: 3 - 2 = 1;
check truth: 4 - 1 = 3;

plusIdRight :: (n: Nat) -> n + 0 = n
{
 fork n
 {
  0      : truth,
  s(n69) : rewrite plusIdRight(n.p); truth,
  }
 }

plusSRight :: (n, m: Nat) -> n + s(m) = s(n+m)
{
 fork n
 {
  0    : truth,
  s(n'): rewrite plusSRight(n.p, m); truth,
  }
 }

plusCommutative :: (n, m: Nat) -> (n + m = m + n)
{
 fork n
 {
  0    : rewrite plusIdRight(m); truth,
  s(n1): rewrite plusCommutative(n.p, m); rewrite plusSRight(m, n.p); truth,
  }
 }

plusAssociative :: (a, b, c: Nat) -> (a+b)+c = a+(b+c)
{
 fork a
 {
  0    : truth,
  s(a'): rewrite plusAssociative(a.p, b, c); truth,
  }
 }

mulDistributive :: (a,b,c: Nat) -> a*c+b*c = (a+b)*c
{
 fork a
 {0: truth,

  s(a'):
  rewrite mulDistributive(a.p, b, c);
  rewrite plusAssociative(c, (a.p * c), (b * c));
  truth}
 }

mulAssociative :: (a,b,c: Nat) -> (a*b)*c = a*(b*c)
{
 fork a
 {
  0: truth,
  s(a'):
  rewrite left mulDistributive(b, (a.p * b), c);
  rewrite mulAssociative(a.p, b, c),
  }
 }

