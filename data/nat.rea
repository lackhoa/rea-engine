#load "boolean.rea"

Nat :: union
{
 0,
 ++: (p: Nat) -> Nat,
 }

+ :: (n, m: Nat) -> Nat
{
 fork n
 {
  0     : m,
  ++(n') : ++(n.p + m),
  }
 }

1 := ++(0);
2 := ++(1);
3 := ++(2);
4 := ++(3);
5 := ++(4);
6 := ++(5);
check truth: 1 + 2 = 3;

pred :: (n : Nat) -> Nat
{
 fork n
 {
  0 : 0,
  ++(n) : n
  }
 }

even :: (n : Nat) -> Bool
{
 fork n
 {
  0      : true,
  ++(n69) : fork n.p {0 : false, ++(n70) : even(n.p.p)},
  }
 }

check truth: even(4) = true;
check truth: even(3) = false;

* :: (n, m: Nat) -> Nat
{
 fork n
 {
  0     : 0,
  ++(n1) : m + n.p * m,
  }
 }

check truth: 2*3 = 6;

- :: (n, m : Nat) -> Nat
{
 fork n
 {
  0     : 0,
  ++(n1) : fork(m) {0 : n, ++(m1) : n.p - m.p}
  }
 }

check truth: 3 - 2 = 1;
check truth: 4 - 1 = 3;

plusIdRight :: (n: Nat) -> n + 0 = n
{
 fork n
 {
  0      : truth,
  ++(n69) : rewrite plusIdRight(n.p); truth,
  }
 }

plusSRight :: (n, m: Nat) -> n + ++(m) = ++(n+m)
{
 fork n
 {
  0    : truth,
  ++(n'): rewrite plusSRight(n.p, m); truth,
  }
 }

plusCommutative :: (n, m: Nat) -> (n + m = m + n)
{
 fork n
 {
  0    : rewrite plusIdRight(m); truth,
  ++(n1): rewrite plusCommutative(n.p, m); rewrite plusSRight(m, n.p); truth,
  }
 }

plusAssociative :: (a, b, c: Nat) -> (a+b)+c = a+(b+c)
{
 fork a
 {
  0    : truth,
  ++(a'): rewrite plusAssociative(a.p, b, c); truth,
  }
 }

mulDistributive :: (a,b,c: Nat) -> a*c+b*c = (a+b)*c
{
 fork a
 {0: truth,

  ++(a'):
  rewrite mulDistributive(a.p, b, c);
  rewrite plusAssociative(c, (a.p * c), (b * c));
  truth}
 }

mulAssociative :: (a,b,c: Nat) -> (a*b)*c = a*(b*c)
{
 fork a
 {
  0: truth,
  ++(a'):
  rewrite left mulDistributive(b, (a.p * b), c);
  rewrite mulAssociative(a.p, b, c),
  }
 }

!= :: (_A: Set, a, b: _A) -> Type
{
 (E: a = b) -> False
 }

multiplicationBetweenPositives :: (a,b: Nat, a_positive: a != 0, b_positive: b != 0) -> a*b != 0
{
 out :: (e: a*b = 0) -> False
 {
  fork a
  {
   0: a_positive(truth),

   ++:
   fork b
   {
    0: b_positive(truth),
    ++: e
    }
   }
  }
 }
