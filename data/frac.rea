#load "frac-base.rea"

addSameDenominator :: (a,b,c: Natp) -> a/c + b/c == (a+b)/c
{
 norm;
 algebra_norm;
 }

cancelCommonFactor :: (a,b,r: Natp) -> (a*r)/(b*r) == a/b
{
 norm;
 algebra_norm;
 }

isFactor :: (r,a: Natp) -> Type
#expand
{
  return exists(t: Natp), a = r*t
  }

relativelyPrime :: (a,b: Natp) -> Type
#expand
{
 return (r: Natp, isFactor(r, a), isFactor(r, b)) -> r = 1
 }

difference :: fn(a,b: Natp, p: a > b = true) -> exists(c: Natp) a = b+c
{ fork a
  { 1  norm p,
    ++ fork b
    { 1
      prove ++(a.p) = 1 + a.p {};
      use evidence with e=a.p;
      ,
      ++
      norm p;
      recurse := difference(a.p,b.p,p);
      prove ++(a.p) = ++(b.p) + recurse.e {norm};
      use evidence with e=recurse.e}}}

Reachable :: union(^R: (a :Natp, b :Natp) -> Type, ^x: Natp)
{
  reachable(p: (y: Natp, lt: y R x) -> Reachable(R, y))
  }

WellFounded :: fn(R: (a: Natp, b: Natp) -> Type) -> Type
{
  return (a: Natp) -> Reachable(R, a)
  }

;; TODO: since we don't have nested fixpoints, we gotta hoist the function out here.
ltWellFounded :: (a: Natp) -> Reachable(lt,a)
{
  pose fn (b: Natp, p: b lt a) -> Reachable(lt, b)
  {
    fork a
    {
      1  norm p,
      ++ norm p;
      recurse := prove Reachable(lt, a.p) {use ltWellFounded};

      pose fn (y: Natp, pyb: y lt b) -> Reachable(lt,y)
      {
        chain := prove y lt a.p {use leChain with b=b};
        use (recurse.p)
        };

      use reachable;
      }
    };
  use reachable;
  }

ltWellFounded : WellFounded(lt) := prove {norm; return ltWellFounded};

QuotientRemainder :: union(^a, ^b: Natp)
{ divideFail(p: b>a = true),  ;; todo use lt
  divideEvenly(quotient: Natp, p: a = quotient*b),
  divideWithRemainder(quotient: Natp, remainder: Natp,
                       p: a = quotient*b + remainder,
                       q: remainder lt b)}

quotientRemainder :: fn(a,b: Natp) -> QuotientRemainder(a,b)
{order := totalOrder(a,b);
  fork order
  {eq
    prove a = 1 * b {norm;}
    return divideEvenly(1, _)
    ,
    lt
    return divideFail(order.p)
    ,
    gt
    diff    := difference(a,b, order.p);
    recurse := quotientRemainder(diff.e, b);
    fork recurse
    {
      divideFail
      prove diff.e lt b {use gtLt};
      use divideWithRemainder with quotient=1, remainder=diff.e;
      ,
      divideEvenly
      prove a = b + recurse.quotient * b {rewrite <- recurse.p}
      use divideEvenly with quotient = ++(recurse.quotient);
      ,
      divideWithRemainder
      prove a = (b + recurse.quotient * b) + recurse.remainder
      {
        => a = b + recurse.quotient * b + recurse.remainder;
        rewrite <- recurse.p;
        }
      use divideWithRemainder with quotient = ++(recurse.quotient), remainder = recurse.remainder
      }
    }
  }

gcd :: (a,b: Natp) -> Maybe(Natp)
{qr := quotientRemainder(a,b);
  fork qr
  {divideFail return none()
    ,
    divideEvenly return some(qr.quotient)
    ,
    divideWithRemainder
    return gcd(b, qr.remainder)
    }}
