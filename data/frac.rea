#load "frac-base.rea"

addSameDenominator :: (a,b,c: Natp) -> a/c + b/c == (a+b)/c
{
 norm;
 algebra_norm;
 }

cancelCommonFactor :: (a,b,r: Natp) -> (a*r)/(b*r) == a/b
{
 norm;
 algebra_norm;
 }

Exists :: union(^$T: Type, ^prop: (x: T) -> Type)
{
 exists(e: T, proof: prop(e))
 }

isFactor :: (r,a: Natp) -> Type
#expand
{
 return Exists(fn(t: Natp) -> Type {return a = r*t})
 }

relativelyPrime :: (a,b: Natp) -> Type
#expand
{
 return (r: Natp, isFactor(r, a), isFactor(r, b)) -> r = 1
 }

;; TODO: could use "exists" here, but the function application is annoying.
Diff :: union(^a,^b: Natp)
{
 diff(c: Natp, e: a = b+c)
 }

#debug
difference :: fn(a,b: Natp, p: a > b = true) -> Diff(a,b)
#tag(function)
{fork a
 {1  norm p;,
  ++ fork b
  {1
   prove ++(a.p) = 1 + a.p {}
   return diff(a.p, _)
   ,
   ++
   norm p;
   }}}
#debug off

print overload(difference, function);

QuotientRemainder :: union(^a, ^b: Natp)
{divideFail(p: b>a = true),
 divideEvenly(quotient: Natp, p: a = quotient*b),
 divideWithRemainder(quotient: Natp, remainder: Natp, p: a = quotient*b + remainder)}

quotientRemainder :: fn(a,b: Natp) -> QuotientRemainder(a,b)
{order := totalOrder(a,b);
 fork order
 {eq
  prove a = 1 * b {norm;}
  return divideEvenly(1, _)
  ,
  lt
  return divideFail(order.p)
  ,
  gt
  }}

gcd :: (a,b: Natp) -> Maybe(Natp)
{qr := quotientRemainder(a,b);
 fork qr
 {invalid return none()
  ,
  divideEvenly return some(qr.quotient)
  ,
  divideWithRemainder
  return gcd(b, qr.remainder)
  }}

quotientRemainderCorrect ::
((a,b: Natp, q,r: Natp, e: quotientRemainder(a,b) = divideWithRemainder(q,r)) ->
 a = q*b + r)
{
 fork a
 {
  1 ,
  }
 }
