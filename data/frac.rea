#load "frac-base.rea"

addSameDenominator :: (a,b,c: Natp) -> a/c + b/c == (a+b)/c
{
 norm;
 algebra_norm;
 }

cancelCommonFactor :: (a,b,r: Natp) -> (a*r)/(b*r) == a/b
{
 norm;
 algebra_norm;
 }

isFactor :: (q,a: Natp) -> Type
#no_expand
{
  return exists(t: Natp), a = q*t
  }

relativelyPrime :: (a,b: Natp) -> Type
{
 return (r: Natp, isFactor(r, a), isFactor(r, b)) -> r = 1
 }

difference :: fn(a,b: Natp, p: a > b = true) -> exists(c: Natp) a = b+c
{ fork a
  { 1  norm p,
    ++ fork b
    { 1
      prove ++(a.p) = 1 + a.p {};
      use evidence with e=a.p;
      ,
      ++
      norm p;
      recurse := difference(a.p,b.p,p);
      prove ++(a.p) = ++(b.p) + recurse.e {norm};
      use evidence with e=recurse.e}}}

;; TODO: since we don't have nested fixpoints, we gotta hoist the function out here.
ltWellFounded_ :: (a: Natp) -> Reachable(<, a)
{
  pose fn (b: Natp, p: (:Type)b < a) -> Reachable(<, b)
  {
    fork a
    {
      1  norm p,
      ++ norm p;
      recurse := prove Reachable(<, a.p) {use ltWellFounded_};

      pose fn (y: Natp, pyb: (:Type)y < b) -> Reachable(<, y)
      {
        chain := prove (:Type)y < a.p {use leChain with b=b};
        use (recurse.p)
        };

      use reachable;
      }
    };
  use reachable;
  }

ltWellFounded : WellFounded(Natp, <) := prove {norm; return ltWellFounded_};

QuotientRemainder :: union(^a, ^b: Natp)
{ divideFail(p: b>a = true),  ;; todo use lt
  divideEvenly(quotient: Natp, p: a = quotient*b),
  divideWithRemainder(quotient: Natp, remainder: Natp,
                       p: a = quotient*b + remainder,
                       q: (:Type) remainder < b) }

quotientRemainder :: fn(a,b: Natp) -> QuotientRemainder(a,b)
#measure(a, ltWellFounded)
{
  order := totalOrder(a,b);
  fork order
  {eq
    prove a = 1 * b {norm;}
    return divideEvenly(1, _)
    ,
    lt
    return divideFail(order.p)
    ,
    gt
    diff    := difference(a,b, order.p);

    ;; TODO: forcing people to use this "use" syntax isn't cool
    recurse := use quotientRemainder with a=diff.e, b=b
    #reduce {rewrite diff.p;
              prove (:Type)b + diff.e > diff.e {=> (:Type)diff.e + b > diff.e;
                                                 use addIncreases}};

    fork recurse
    {
      divideFail
      prove (:Type)diff.e < b {use gtLt};
      use divideWithRemainder with quotient=1, remainder=diff.e;
      ,
      divideEvenly
      prove a = b + recurse.quotient * b {rewrite <- recurse.p}
      use divideEvenly with quotient = ++(recurse.quotient);
      ,
      divideWithRemainder
      prove a = (b + recurse.quotient * b) + recurse.remainder
      {
        => a = b + recurse.quotient * b + recurse.remainder;
        rewrite <- recurse.p;
        }
      use divideWithRemainder with quotient = ++(recurse.quotient), remainder = recurse.remainder
      }
    }
  }

isCommonDivisor :: (q, a,b: Natp) -> Type
#no_expand
{
  return isFactor(q, a) /\ isFactor(q,b)
  }

isGcd :: (q, a,b: Natp) -> Type
#no_expand
{
  return (isCommonDivisor(q,a,b) /\
           ((q': Natp, isCommonDivisor(q',a,b)) -> isFactor(q', q)))
  }

< :: (p1,p2: Natp /\ Natp) -> Type
#no_expand #tag(lexicographic)
{
  return (p1.a < p2.a \/
          p1.a = p2.a /\ p1.b < p2.b)
  }

lexicoLtLemma ::
(a,b: Natp, x: Natp /\ Natp, lt: x < pair(a,++(b)))
-> x = pair(a,b) \/ x < pair(a,b)
{
  norm unfold(<) lt;
  fork lt
  {
    auto
    prove x < pair(a,b) {norm unfold(<); use left}
    use right
    ,
    auto
    ;; ltLemma :: (a,b: Natp, p: (:Type)a < ++(b)) -> a=b \/ (:Type)a < b
    lemma := prove x.b = b \/ x.b < b
    {prove (:Type)++(x.b) <= ++(b) {norm; return lt.b.b}; use ltLemma};

    fork lemma
    {
      auto
      prove (x = pair(a,b)) {rewrite lemma.a; rewrite lt.b.a}
      use left;
      ,
      auto
      prove pair(x.a, x.b) < pair(a, b)
      {
        norm unfold(<);
        prove x.a = a /\ ++(x.b) <= b = true {use pair with a=lt.b.a};
        use right;}
      use right;
      }
    }
  }

lexicoReachableLocked ::
(a,b: Natp, h: Reachable(<, pair(a, (:Natp)1)))
->
Reachable(<, pair(a,b))
{
  fork b
  {
    1,
    ++
    pose fn (y: Natp /\ Natp, lt: y < pair(a,b)) -> Reachable(<, y)
    {
      lt' := lt;  ;; save it before we norm it away
      norm unfold(<) lt;  ;; todo as lt';
      fork lt
      {
        auto
        ;; y.a < a -> y is less than (a,1)
        prove y < pair(a,1) {norm unfold(<); use left};
        use (h.p);
        ,
        auto
        ;; y.a = a; y.b <= b.p
        ih : Reachable(<, pair(a, b.p)) := use lexicoReachableLocked with a=a, b=b.p;

        ;; either "y = a,b.p" in which case the induction hypothesis applies
        ;; or "y < a,b.p", in which case the induction hypothesis also applies

        lemma := use lexicoLtLemma with lt=lt';
        fork lemma
        {
          auto
          rewrite lemma.a
          ,
          auto
          use (ih.p)
          }
        }
      };
    use reachable;
    }
  }

lexicoWellFounded1 :: (b: Natp) -> Reachable(<, pair((:Natp)1,b))
{
  super_base_case := prove Reachable(<, pair((:Natp)1, (:Natp)1))
  {
    pose fn (y: Natp /\ Natp, lt: y < pair(1,1)) -> Reachable(<, y)
    {
      norm unfold(<) lt; fork lt {auto fork lt.a {}, auto fork lt.b. b {}}
      };
    use reachable;
    };

  fork b
  {
    1 return super_base_case,
    ++ use lexicoReachableLocked;
    }
  }

lexicoWellFounded_ :: (a: Natp, b: Natp) -> Reachable(<, pair(a,b))
{
  fork a
  {
    1 use lexicoWellFounded1
    ,
    ++
    if_b_is_1 := prove Reachable(<, pair(a, (:Natp)1))
    {
      ;; Anything that "rolls under" to a.p is gonna be resolved by induction.
      pose fn (y: Natp /\ Natp, lt: y < pair(a, 1)) -> Reachable(<, y)
      {
        norm unfold(<) lt;
        fork lt
        {
          auto
          prove y < pair(a.p, ++(y.b))
          {
            norm unfold(<);
            lemma := use ltLemma with a=y.a, b=a.p;
            fork lemma
            {
              auto
              prove y.a = a.p /\ y.b <= y.b = true {use pair;}
              use right;
              ,
              auto
              use left;
              }
            }
          ih := use lexicoWellFounded_ with a=a.p, b = ++(y.b);
          use (ih.p);
          ,
          auto
          fork lt.b.b {}
          }
        };
      use reachable;
      };

    fork b
    {
      1 return if_b_is_1,
      ++ use lexicoReachableLocked
      }
    }
  }

lexicoWellFounded : WellFounded(Natp/\Natp, <) := prove {norm; lexicoWellFounded_};

gcd :: (a,b: Natp) -> exists(out: Natp) isGcd(out, a,b)
#measure(pair(a,b), lexicoLtWellFounded)
{
  ;; NOTE: we try to keep a < b.
  qr := quotientRemainder(b,a);
  fork qr
  {
    divideFail
    prove {
            use gcd with a=b,b=a
            #reduce {};
            }
    ,
    divideEvenly return some(qr.quotient)
    ,
    divideWithRemainder
    return gcd(qr.remainder, b)}}
