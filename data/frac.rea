#load "frac-base.rea"

addSameDenominator :: (a,b,c: Natp) -> a/c + b/c == (a+b)/c
{
 norm;
 algebra_norm;
 }

cancelCommonFactor :: (a,b,r: Natp) -> (a*r)/(b*r) == a/b
{
 norm;
 algebra_norm;
 }

isFactor :: (r,a: Natp) -> Type
#expand
{
  return exists(t: Natp), a = r*t
  }

relativelyPrime :: (a,b: Natp) -> Type
#expand
{
 return (r: Natp, isFactor(r, a), isFactor(r, b)) -> r = 1
 }

difference :: fn(a,b: Natp, p: a > b = true) -> exists(c: Natp) a = b+c
{ fork a
  { 1  norm p,
    ++ fork b
    { 1
      prove ++(a.p) = 1 + a.p {};
      use evidence with e=a.p;
      ,
      ++
      norm p;
      recurse := difference(a.p,b.p,p);
      prove ++(a.p) = ++(b.p) + recurse.e {norm};
      use evidence with e=recurse.e}}}

;; TODO: since we don't have nested fixpoints, we gotta hoist the function out here.
ltWellFounded_ :: (a: Natp) -> Reachable(<, a)
{
  pose fn (b: Natp, p: (:Type)b < a) -> Reachable(<, b)
  {
    fork a
    {
      1  norm p,
      ++ norm p;
      recurse := prove Reachable(<, a.p) {use ltWellFounded_};

      pose fn (y: Natp, pyb: (:Type)y < b) -> Reachable(<, y)
      {
        chain := prove (:Type)y < a.p {use leChain with b=b};
        use (recurse.p)
        };

      use reachable;
      }
    };
  use reachable;
  }

ltWellFounded : WellFounded(Natp, <) := prove {norm; return ltWellFounded_};

QuotientRemainder :: union(^a, ^b: Natp)
{ divideFail(p: b>a = true),  ;; todo use lt
  divideEvenly(quotient: Natp, p: a = quotient*b),
  divideWithRemainder(quotient: Natp, remainder: Natp,
                       p: a = quotient*b + remainder,
                       q: (:Type) remainder < b) }

quotientRemainder :: fn(a,b: Natp) -> QuotientRemainder(a,b)
#measure(a, ltWellFounded)
{order := totalOrder(a,b);
  fork order
  {eq
    prove a = 1 * b {norm;}
    return divideEvenly(1, _)
    ,
    lt
    return divideFail(order.p)
    ,
    gt
    diff    := difference(a,b, order.p);

    ;; TODO: forcing people to use this "use" syntax isn't cool
    recurse := use quotientRemainder with a=diff.e, b=b
    #reduce {rewrite diff.p;
              prove (:Type)b + diff.e > diff.e {=> (:Type)diff.e + b > diff.e;
                                                 use addIncreases}};

    fork recurse
    {
      divideFail
      prove (:Type)diff.e < b {use gtLt};
      use divideWithRemainder with quotient=1, remainder=diff.e;
      ,
      divideEvenly
      prove a = b + recurse.quotient * b {rewrite <- recurse.p}
      use divideEvenly with quotient = ++(recurse.quotient);
      ,
      divideWithRemainder
      prove a = (b + recurse.quotient * b) + recurse.remainder
      {
        => a = b + recurse.quotient * b + recurse.remainder;
        rewrite <- recurse.p;
        }
      use divideWithRemainder with quotient = ++(recurse.quotient), remainder = recurse.remainder
      }
    }
  }

gcd :: (a,b: Natp) -> Maybe(Natp)
{qr := quotientRemainder(a,b);
  fork qr
  {divideFail return none()
    ,
    divideEvenly return some(qr.quotient)
    ,
    divideWithRemainder
    return gcd(b, qr.remainder)
    }}
