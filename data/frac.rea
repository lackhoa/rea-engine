#load "natp.rea"

Frac :: union {/(n,d: Natp)}

== :: fn(a,b: Frac) -> Type
{return a.n*b.d = a.d*b.n}

+ :: fn(a,b: Frac) -> Frac
{return (a.n*b.d + a.d*b.n) / (a.d*b.d)}

* :: fn(a,b: Frac) -> Frac
{return (a.n*b.n) / (a.d*b.d)}

addCommutative :: (a,b: Frac) -> a+b == b+a
#hint
{
 norm;
 algebra_norm;
 }

addAssociative :: (a,b,c: Frac) -> (a+b)+c == a+b+c
#hint
{
 norm;
 algebra_norm;
 }
