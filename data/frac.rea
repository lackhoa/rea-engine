#load "frac-base.rea"

addSameDenominator :: (a,b,c: Natp) -> a/c + b/c == (a+b)/c
{
 norm;
 algebra_norm;
 }

cancelCommonFactor :: (a,b,r: Natp) -> (a*r)/(b*r) == a/b
{
 norm;
 algebra_norm;
 }

Exists :: union(^$T: Type, ^prop: (x: T) -> Type)
{
 exists(e: T, proof: prop(e))
 }

isFactor :: (r,a: Natp) -> Type
#expand
{
 return Exists(fn(t: Natp) -> Type {return a = r*t})
 }

relativelyPrime :: (a,b: Natp) -> Type
#expand
{
 return (r: Natp, isFactor(r, a), isFactor(r, b)) -> r = 1
 }

;; TODO: could use "exists" here, but the function application is annoying.
Diff :: union(^a,^b: Natp)
{
 diff(c: Natp, e: a = b+c)
 }

difference :: fn(a,b: Natp, p: a > b = true) -> Diff(a,b)
{ fork a
  { 1  norm p,
    ++ fork b
    { 1
      prove ++(a.p) = 1 + a.p {}
      return diff(a.p, _)
      ,
      ++
      norm p;
      recurse := difference(a.p,b.p,p);
      prove ++(a.p) = ++(b.p) + recurse.c {norm};
      use diff with c=recurse.c}}}

QuotientRemainder :: union(^a, ^b: Natp)
{ divideFail(p: b>a = true),
  divideEvenly(quotient: Natp, p: a = quotient*b),
  divideWithRemainder(quotient: Natp, remainder: Natp, p: a = quotient*b + remainder)}

;; Inductive Acc (x: A) : Prop :=
;;     Acc_intro : (forall y:A, R y x -> Acc y) -> Acc x.

Reachable :: union(^R: (a :Natp, b :Natp) -> Type, ^x: Natp)
{
  reachable(p: (y: Natp, lt: y R x) -> Reachable(R, y))
  }

WellFounded :: fn(R: (a: Natp, b: Natp) -> Type) -> Type
{
  return (a: Natp) -> Reachable(R, a)
  }

le :: fn(a,b: Natp) -> Type
#expand
{
  return a <= b = true
  }

lt :: fn(a,b: Natp) -> Type
#expand
{
  return a < b = true
  }

le1 :: ($a: Natp, p: a le 1) -> a=1
{fork a {1, ++ norm p;}}

ltLemma :: (a,b: Natp, p: a lt ++(b)) -> a=b \/ a lt b
{
  fork a
  {
    1 fork b {1 use leftDisjunct, ++ use rightDisjunct}
    ,
    ++ fork b
    { 1 norm p,
      ++
      norm p;
      recurse := use ltLemma with a=a.p, b=b.p, p=p;
      norm recurse;
      }
    }
  }

leChain :: (a,b,c: Natp, p: a le b, q: b le c) -> a le c
#norm(p,q)
{
  fork c
  { 1 pose le1(q); rewrite b=1 in p,
    ++ fork b
    { 1  pose le1(p); rewrite a=1, 
      ++ fork a
      { 1  ,
        ++ use leChain with b=b.p
        }
      }}
  }

ltChain :: (a,b,c: Natp, p: a lt b, q: b lt c) -> a lt c
{
  fork c
  {
    1  norm q,
    ++ fork b
    {1 norm p,
      ++ fork a {1, ++ norm p; norm q;
                  prove a.p lt b.p {norm};
                  prove b.p lt c.p {norm};
                  use ltChain with b=b.p}}
    }
  }

;; TODO: since we don't have nested fixpoints, we gotta hoist the function out here.
ltWellFounded :: (a: Natp) -> Reachable(lt,a)
{
  useme := fn (b: Natp, p: b lt a) -> Reachable(lt, b)
  {
    fork a
    {
      1  norm p,
      ++ norm p;
      recurse := prove Reachable(lt, a.p) {use ltWellFounded};

      useme := fn (y: Natp, pyb: y lt b) -> Reachable(lt,y)
      {
        chain := prove y lt a.p {use leChain with b=b};
        use (recurse.p)
        };

      use reachable with p=useme;
      }
    };
  use reachable with p=useme;
  }

ltWellFounded : WellFounded(lt) := prove {norm; return ltWellFounded};

quotientRemainder :: fn(a,b: Natp) -> QuotientRemainder(a,b)
{order := totalOrder(a,b);
  fork order
  {eq
    prove a = 1 * b {norm;}
    return divideEvenly(1, _)
    ,
    lt
    return divideFail(order.p)
    ,
    gt
    diff    := difference(a,b, order.p);
    recurse := quotientRemainder(diff.c, b);
    }}

gcd :: (a,b: Natp) -> Maybe(Natp)
{qr := quotientRemainder(a,b);
  fork qr
  {divideFail return none()
    ,
    divideEvenly return some(qr.quotient)
    ,
    divideWithRemainder
    return gcd(b, qr.remainder)
    }}

quotientRemainderCorrect ::
((a,b: Natp, q,r: Natp, e: quotientRemainder(a,b) = divideWithRemainder(q,r)) ->
 a = q*b + r)
{
 fork a
 {
  1 ,
  }
 }
