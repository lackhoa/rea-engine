#load "boolean.rea"
#load "nat.rea"

#should_fail
check truth: true = false;
#should_fail off

RatTest :: union
{
 / : (n,d: Nat, _dnot0: d != 0) -> RatTest
 }

BigStruct :: union
{
 makeBigStruct : (r: RatTest) -> BigStruct
 }

testBigStruct :: (big : BigStruct) -> (big.r.d != 0)
{
 big.r._dnot0
 }

testRatArrow :: (r: RatTest) -> r.d != 0 { r._dnot0 }

testRatArrow2 :: () -> (a: RatTest) -> (a.d = a.d)
{
 out :: (b: RatTest) -> (b.d = b.d) {truth}
 out
 }

+ :: (a, b: RatTest) -> RatTest
{
 /((a.n * b.d + b.n * a.d), (a.d * b.d),
   multiplyPos(a.d, b.d, a._dnot0, b._dnot0))
 }

Pos :: union
{
 1,
 ++: (p: Pos) -> Pos,
 }

+ :: (a, b: Pos) -> Pos
{
 fork a
 {
  1: ++(b),
  ++: ++(a.p+b)
  }
 }

2 : Pos := ++(1);
3 : Pos := ++(2);
check 1+2: Nat;
check 1+2: Pos;
;; #should_fail
;; check 1+2: RatTest;
;; #should_fail off
