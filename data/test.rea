#load "boolean.rea"
#load "nat.rea"

#should_fail
check truth: true = false;
#should_fail off

;; todo this can be just be a struct
RatTest :: union
{
 / : struct {n,d: Nat, _dnot0: d != 0}
 }

BigStruct :: union
{
 makeBigStruct : struct {r: RatTest}
 }

testBigStruct :: fn (big : BigStruct) -> (big.r.d != 0)
{
 big.r._dnot0
 }

testRatArrow :: fn (r: RatTest) -> r.d != 0 { r._dnot0 }

testRatArrow2 :: fn () -> (a: RatTest) -> (a.d = a.d)
{
 out :: fn (b: RatTest) -> (b.d = b.d) {}
 out
 }

+ :: fn (a, b: RatTest) -> RatTest
{
 /(a.n * b.d + b.n * a.d,
   a.d * b.d,
   multiplyPos(a.d, b.d, a._dnot0, b._dnot0))
 }

Nat+ :: union
{1,
 ++: struct {p: Nat+}}

+ :: fn (a, b: Nat+) -> Nat+
{fork a
 {1 : ++(b),
  ++: ++(a.p + b)}}

2 : Nat+ := ++(1);
3 : Nat+ := ++(2);
check 1+2: Nat;
check 1+2: Nat+;
#should_fail
check 1+2: RatTest;
#should_fail off

* :: fn (n, m: Nat+) -> Nat+
{fork n
 {1  : m,
  ++ : m + n.p * m}}

Z :: union
{0,
 ;; todo: These maybe not work work as unary operators?
 +: struct {v: Nat+},
 -: struct {v: Nat+}}

;; - :: (a: Nat+, b: Nat+) -> Nat+
;; {;; assuming that a > b
;;  fork a
;;  {1 : 1,
;;   ++: fork b {1: 1, ++: -(a.p, b.p)}}}

;; compare :: (a: Nat+, b: Nat+) -> Nat+
;; {fork a
;;  {1  : fork b {1: 0, ++: -},
;;   ++ : fork b {1: +, ++: compare(a.p, b.p)}}}

+ :: fn (a, b: Z) -> Z
{fork a
 {0: b,

  +:
  fork b
  {0: a,
   +: +(a.v + b.v),
   -:  ;; a positive, b negative
   fork (a.v)
   {1 : fork (b.v) {1: 0, ++: -(b.v.p)},
    ++: fork (b.v) {1: +(a.v.p), ++: +(a.v.p) + -(b.v.p)}}},

  -:
  fork b
  {0: a,
   +: ;; a negative, b positve: symmetric case
   b + a,
   -: ;; both negative
   -(a.v + b.v)}}}

;; NOTE: this is negation, not to be confused with the actual constructor "-" for Z
- :: fn (a: Z) -> Z
{fork a {0: 0, +: -(a.v), -: +(a.v)}}

* :: fn (a,b : Z) -> Z
{fork a
 {0: 0,
  +: fork b {0: 0, +: +(a.v * b.v), -: -(a.v * b.v)},
  -: -(+(a.v) * b)}}

;; Rat+ :: union { /: (n,d: Nat+) -> Rat+ }
;; Rat :: union { 0, +: (v: Rat+) -> Rat, -: (v: Rat+) -> Rat }
Rat :: union { /: struct {n: Z, d: Nat+} }

+ :: fn (a,b: Rat) -> Rat
{;; todo: type coercion
 n : Z := a.n * +(b.d) + b.n * +(a.d);
 d : Nat+ := a.d * b.d;
 n / d
 }

add1 :: (a: Nat+) -> a+1 = ++(a)
{fork a
 {1 : ,
  ++: rewrite add1(a.p)}}

addSRight :: (a,b: Nat+) -> a + ++(b) = ++(a+b)
{fork a
 {1 :,
  ++: rewrite addSRight(a.p, b)}}

addCommutative :: (a, b: Nat+) -> (a + b = b + a)
{fork a
 {1 : rewrite add1(b),
  ++:
  rewrite addSRight(b, a.p);
  rewrite addCommutative(a.p, b)}}

;; todo #copypasta collapse these abstract algebra down maybe
addAssociative :: (a,b,c: Nat+) -> (a+b)+c = a+b+c
{fork a
 {1 : ,
  ++: rewrite addAssociative(a.p, b, c)}}

mulDistributive :: (a,b,c: Nat+) -> a*c+b*c = (a+b)*c
{fork a
 {1: ,
  ++:
  rewrite addAssociative(c, (a.p * c), (b * c));
  rewrite mulDistributive(a.p, b, c)}}

mulAssociative :: (a,b,c: Nat+) -> (a*b)*c = a*b*c
{fork a
 {1 : ,
  ++:
  rewrite <- mulDistributive(b, (a.p * b), c);
  rewrite mulAssociative(a.p, b, c)}}

mul1 :: (a: Nat+) -> a*1 = a
{fork a
 {1 : ,
  ++: rewrite mul1(a.p)}}
;; print mul1;

mulSRight :: (a,b: Nat+) -> a * ++(b) = a + a*b
{fork a
 {1:,
  ++:
  => ++(b + a.p * ++(b))   = ++(a.p + b + a.p*b)
  => ++(b + a.p + a.p*b)   = ++(a.p + b + a.p*b) { mulSRight(a.p, b) }
  => ++((a.p + a.p*b) + b) = ++(a.p + b + a.p*b) { addCommutative(b, a.p + a.p*b) }
  => ++(a.p + a.p*b + b)   = ++(a.p + b + a.p*b) { addAssociative(a.p, a.p*b, b) }
  => ++(a.p + a.p*b + b)   = ++(a.p + a.p*b + b) { addCommutative(b, a.p*b) }}}
;; print(mulSRight);

mulCommutative :: (a,b: Nat+) -> a*b = b*a
{fork a
 {1 : rewrite mul1(b),
  ++: 
  => b + a.p*b = b * ++(a.p)
  => b + a.p*b = b + b*a.p { mulSRight(b, a.p) }
  => b + a.p*b = b + a.p*b { <- mulCommutative(a.p, b) }}}

add0 :: (a: Z) -> a+0 = a
{fork a {0: , +: , -: }}

mul0 :: (a: Z) -> a*0 = 0
{fork a {0:, +:, -: }}

mul1Left :: (a: Z) -> +(1) * a = a
{fork a {0:,+:,-:}}

cancellation :: (a: Nat+) -> +(a) + -(a) = 0
{fork a {1:,
         ++: => +(a.p) + -(a.p) = 0;
         rewrite cancellation(a.p)}}

;; todo: bug with the heap value name: in the fork of a.v
;; expected type: +(..p) + -(..p) = 0
cancellation :: (a: Z) -> a + -(a) = 0
{fork a {0: ,
         +: rewrite cancellation(a.v),
         -: rewrite cancellation(a.v)}}

mulSLeft :: (a: Nat+, b: Z) -> (+(++(a)) * b) = b + +(a)*b
{=> +(++(a)) * b = b + +(a) * b;
 fork b
 {0:, +:, -:}}

addCommutativeOpposite :: (a,b: Nat+) -> +(a) + -(b) = -(b) + +(a)
{fork a {1:, ++: }}

negationOfSumOpposite :: (a,b: Nat+) -> -(+(a) + -(b)) = +(b) + -(a) 
{fork a
 {1 : fork b {1:, ++:},
  ++: fork b {1:, ++: rewrite negationOfSumOpposite(a.p, b.p)}}}

negationOfSum :: (a, b: Z) -> -(a + b) = -(a) + -(b)
{fork a
 {0: ,
  +: fork (b) {0: , +:,
            -: => -(+(a.v) + -(b.v)) = +(b.v) + -(a.v);
            => +(b.v) + -(a.v) = +(b.v) + -(a.v) {negationOfSumOpposite}},
  -: fork(b) {0:,
              +: => -(+(b.v) + -(a.v)) = +(a.v) + -(b.v)
              => +(a.v) + -(b.v) = +(a.v) + -(b.v) {negationOfSumOpposite},
              -:}}}

addCommutativePositive :: (a: Nat+, b: Z) -> +(a) + b = b + +(a)
{fork a
 {1: fork b {0:, +: rewrite add1(b.v), -:},
  ++: fork b {0:,
              +: rewrite addCommutative(b.v, ++(a.p));
              => _,
              -:}}}

addCommutativeNegative :: (a: Nat+, b: Z) -> -(a) + b = b + -(a)
{fork a
 {1: fork b {0:, +: , -: rewrite add1(b.v)},
  ++: fork b {0:,
              +: ,
              -: rewrite addCommutative(b.v, ++(a.p)); => _}}}

addCommutative :: (a,b: Z) -> a+b = b+a
{fork(a)
 {0: rewrite add0(b),
  +: addCommutativePositive(a.v, b),
  -: addCommutativeNegative(a.v, b)}}

SToAdd1 :: (a: Nat+) -> +(++(a)) = +(1) + +(a)
{fork a {1 :, ++: }}

;; addSLeft :: (a: Nat+, b: Z) -> +(++(a)) + b = +(1) + (+(a) + b)
;; {fork a
;;  {1 : fork b {0:,+:,-: fork b.v {1:, ++:}},
;;   ++: => +(++(++(a.p))) + b = +(1) + +(++(a.p)) + b;
;;   rewrite SToAdd1(++(a.p));
;;   ;; fork b {0:,+:,
;;   ;;             -:
;;   ;;             => +(++(++(a.p))) + -(b.v) = +(1) + +(++(a.p)) + -(b.v)}
;;   }}

<= :: fn (a,b: Nat+) -> Bool
{fork a
 {1: true, ++: fork b {1: false, ++: a.p <= b.p}}}

add1Associative :: (b,c: Z) -> (+(1)+b)+c = +(1)+b+c
{fork b {0:,
         +: => +(++(b.v)) + c = +(1) + +(b.v) + c;
         fork c {0:,+:,
                 -: => +(++(b.v)) + -(c.v) = +(1) + +(b.v) + -(c.v);
                 fork b.v
                 {1: => +(++(1)) + -(c.v) = +(1) + +(1) + -(c.v);
                  fork c.v {1:, ++:},
                  ++: => +(++(++(b.v.p))) + -(c.v) = +(1) + +(++(b.v.p)) + -(c.v);
                  fork c.v {1:,
                            ++: => +(++(b.v.p)) + -(c.v.p) = +(1) + +(b.v.p) + -(c.v.p);
                            rewrite SToAdd1(b.v.p);
                            => (+(1) + +(b.v.p)) + -(c.v.p) = +(1) + +(b.v.p) + -(c.v.p);
                            rewrite add1Associative(+(b.v.p), -(c.v.p))}}},
         -: => (+(1) + -(b.v)) + c = +(1) + -(b.v) + c;
         fork c {0: => (+(1) + -(b.v)) + 0 = +(1) + -(b.v);
                 rewrite add0(+(1) + -(b.v)),
                 +: => (+(1) + -(b.v)) + +(c.v) = +(1) + +(c.v) + -(b.v);
                 fork b.v {1 : => +(c.v) = +(1) + +(c.v) + -(1); fork c.v {1:, ++:},
                           ++: => +(c.v) + -(b.v.p) = +(1) + +(c.v) + -(++(b.v.p));
                           fork c.v
                           {1: ,
                            ++: => +(++(c.v.p)) + -(b.v.p) = +(1) + +(c.v.p) + -(b.v.p);
                            rewrite SToAdd1(c.v.p);
                            => (+(1) + +(c.v.p)) + -(b.v.p) = +(1) + +(c.v.p) + -(b.v.p);
                            add1Associative(+(c.v.p), -(b.v.p))}},
                 -: fork b.v {1 :, ++:}}}}

sumCancellation :: (a,b,c: Z, P: a+b=a+c) -> (b=c)
{
 fork a
 {0: norm P; P,
  +: norm P,
  ;; fork a.v {1: _
  ;;              ;; norm P;
  ;;              ;; fork b
  ;;              ;; {0: fork c {0:, +:, -:},
  ;;              ;;  +:,
  ;;              ;;  -:,}
  ;;              ,

  ;;              ++:},
  -: }
 }

addAssociative :: (a,b,c: Z) -> (a+b)+c = a+b+c
{fork a
 {0:,
  +: => (+(a.v) + b) + c = +(a.v) + b + c;
  fork a.v
  {1: fork b {0:,
              +: => +(++(b.v)) + c = +(1) + +(b.v) + c;
              fork c
              {0:,
               +:,
               -: => +(++(b.v)) + -(c.v) = +(1) + +(b.v) + -(c.v)
               => (+(1) + +(b.v)) + -(c.v) = +(1) + +(b.v) + -(c.v) {SToAdd1}
               => +(1) + +(b.v) + -(c.v) = +(1) + +(b.v) + -(c.v) {add1Associative}},

              -: => (+(1) + -(b.v)) + c = +(1) + -(b.v) + c
              => +(1) + -(b.v) + c = +(1) + -(b.v) + c {add1Associative}},
   ++: => (+(++(a.v.p)) + b) + c = +(++(a.v.p)) + b + c
   => ((+(1) + +(a.v.p)) + b) + c = +(++(a.v.p)) + b + c {SToAdd1}
   => ((+(1) + +(a.v.p)) + b) + c = (+(1) + +(a.v.p)) + b + c {SToAdd1}
   => (+(1) + +(a.v.p) + b) + c = (+(1) + +(a.v.p)) + b + c {add1Associative}
   => +(1) + (+(a.v.p) + b) + c = (+(1) + +(a.v.p)) + b + c {add1Associative}
   => +(1) + (+(a.v.p) + b) + c = +(1) + (+(a.v.p) + b + c) {add1Associative}
   rewrite addAssociative(+(a.v.p), b, c)}
  ,
  -: => (-(a.v) + b) + c = -(a.v) + b + c;
  fork a.v
  {1:  ,
   ++: }
  }
 }

mulDistributive :: (a,b,c: Z) -> a*c+b*c = (a+b)*c
{fork a
 {0: ,
  +: fork b
  {0: add0((+(a.v) * c)),
   +:
   => +(a.v) * c + +(b.v) * c = +(a.v + b.v) * c;
   fork c
   {0: ,
    +: => +(a.v * c.v + b.v * c.v) = +((a.v + b.v) * c.v)
    => +((a.v + b.v) * c.v) = +((a.v + b.v) * c.v) {mulDistributive}
    ,
    -: => -(a.v * c.v + b.v * c.v) = -((a.v + b.v) * c.v)
    => -((a.v + b.v) * c.v) = -((a.v + b.v) * c.v) {mulDistributive},},

   -: => +(a.v) * c + -(+(b.v) * c) = (+(a.v) + -(b.v)) * c;
   fork a.v
   {1 : => +(1) * c + -(+(b.v) * c) = (+(1) + -(b.v)) * c
    => c + -(+(b.v) * c) = (+(1) + -(b.v)) * c {mul1Left}
    fork b.v {1 : rewrite mul1Left(c); rewrite cancellation(c),
              ++:
              => c + -(+(++(b.v.p)) * c) = -(+(b.v.p) * c)
              => c + -(c + +(b.v.p) * c) = -(+(b.v.p) * c) {mulSLeft}
              => c + -(c) + -(+(b.v.p) * c) = -(+(b.v.p) * c) {negationOfSum}
              => (c + -(c)) + -(+(b.v.p) * c) = -(+(b.v.p) * c) {<- addAssociative}
              }
    ,
    ++: }
   },
  -: }}

addAssociative :: (a,b,c: Rat) -> (a+b)+c = a+b+c
{rewrite(mulAssociative(a.d, b.d, c.d))}
