#load "boolean.rea"
#load "nat.rea"

testComplexFork :: (a, b: Nat) -> Nat
{
 fork a+b
 {
  0:    0,
  s(n): (a+b).p,
  }
 }
check truth: testComplexFork(0, 0) = 0;
check truth: testComplexFork(1, 1) = 1;

testLocalVariable :: (x: Nat) -> Nat
{
 a := 3;
 b := 2;
 a + x + b;
 }
check truth: testLocalVariable(1) = 6;

testCurrying :: (a: Nat) -> (b, c: Nat) -> (a+b)+c = a+(b+c)
{
 fork a
 {
  s(a'):
  out69 :: (b', c': Nat) -> (a+b')+c' = a+b'+c'
  { plusAssociative(a, b', c') }
  out69,

  0:
  out70 :: (b, c: Nat) -> (a+b)+c = a+(b+c)
  { plusAssociative(a, b, c) }
  out70,
  }
 }

testCurrying2 :: (a, b, c: Nat) -> (a+b)+c = a+(b+c)
{
 fun :: (b',c': Nat) -> (a+b')+c' = a+(b'+c')
 { plusAssociative(a, b', c') }

 fun(b,c)
 }

testCurrying3 :: (a: Nat) -> Nat
{
 b := 3;
 f :: (n: Nat) -> Nat { n*b }
 f(a)
 }
check truth: testCurrying3(2) = 6;

mulDistributive :: (a,b,c: Nat) -> a*c+b*c = (a+b)*c
{
 fork a
 {0: truth,

  s(a'):
  rewrite mulDistributive(a.p, b, c);
  rewrite plusAssociative(c, (a.p * c), (b * c));
  truth}
 }

mulAssociative :: (a,b,c: Nat) -> (a*b)*c = a*(b*c)
{
 fork a
 {
  0: truth,
  s(a'):
  rewrite left mulDistributive(b, (a.p * b), c);
  rewrite mulAssociative(a.p, b, c),
  }
 }

!= :: (_A: Set, a, b: _A) -> Type
{
 (E: a = b) -> False
 }

Rat :: union
{
 / : (n,d: Nat, _dnot0: d != 0) -> Rat
 }

testRatArrow :: (r: Rat) -> r.d != 0 { r._dnot0 }

testRatArrow2 :: () -> (a: Rat) -> (a.d = a.d)
{
 out :: (b: Rat) -> (b.d = b.d) {truth}
 out
 }

;; todo operator overload
rat_plus :: (a, b: Rat) -> Rat
{
 fork a
 {
  /(an,ad,aproof): 
  fork b
  {
   /(bn,bd,bproof):
   /((a.n * b.d + b.n * a.d), (a.d * b.d), a._dnot0)
   }
  }
 }
