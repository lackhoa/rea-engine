#load "boolean.rea"
#load "nat.rea"

#should_fail
check truth: true = false;
#should_fail off

RatTest :: union
{
 / : (n,d: Nat, _dnot0: d != 0) -> RatTest
 }

BigStruct :: union
{
 makeBigStruct : (r: RatTest) -> BigStruct
 }

testBigStruct :: fn (big : BigStruct) -> (big.r.d != 0)
{
 big.r._dnot0
 }

testRatArrow :: fn (r: RatTest) -> r.d != 0 { r._dnot0 }

testRatArrow2 :: fn () -> (a: RatTest) -> (a.d = a.d)
{
 out :: fn (b: RatTest) -> (b.d = b.d) {}
 out
 }

+ :: fn (a, b: RatTest) -> RatTest
{
 /((a.n * b.d + b.n * a.d), (a.d * b.d),
   multiplyPos(a.d, b.d, a._dnot0, b._dnot0))
 }

Pos :: union
{
 1,
 ++: (p: Pos) -> Pos,
 }

+ :: fn (a, b: Pos) -> Pos
{fork a
 {1 : ++(b),
  ++: ++(a.p + b)}}

2 : Pos := ++(1);
3 : Pos := ++(2);
check 1+2: Nat;
check 1+2: Pos;
#should_fail
check 1+2: RatTest;
#should_fail off

* :: fn (n, m: Pos) -> Pos
{
 fork n
 {
  1  : m,
  ++ : m + n.p * m,
  }
 }

Z :: union
{0,
 ;; todo: These maybe not work work as unary operators?
 +: (v: Pos) -> Z,
 -: (v: Pos) -> Z}

;; - :: (a: Pos, b: Pos) -> Pos
;; {;; assuming that a > b
;;  fork a
;;  {1 : 1,
;;   ++: fork b {1: 1, ++: -(a.p, b.p)}}}

;; compare :: (a: Pos, b: Pos) -> Pos
;; {fork a
;;  {1  : fork b {1: 0, ++: -},
;;   ++ : fork b {1: +, ++: compare(a.p, b.p)}}}

+ :: fn (a, b: Z) -> Z
{fork a
 {0: b,

  +:
  fork b
  {0: a,
   +: +(a.v + b.v),
   -:  ;; a positive, b negative
   fork (a.v)
   {1 : fork (b.v) {1: 0, ++: -(b.v.p)},
    ++: fork (b.v) {1: +(a.v.p), ++: +(a.v.p) + -(b.v.p)}}},

  -:
  fork b
  {0: a,
   +: ;; a negative, b positve: symmetric case
   b + a,
   -: ;; both negative
   -(a.v + b.v)}}}

;; NOTE: this is negation, not to be confused with the actual constructor "-" for Z
- :: fn (a: Z) -> Z
{fork a {0: 0, +: -(a.v), -: +(a.v)}}

* :: fn (a,b : Z) -> Z
{fork a
 {0: 0,
  +: fork b {0: 0, +: +(a.v * b.v), -: -(a.v * b.v)},
  -: -(+(a.v) * b)}}

Rat :: union { /: (n: Z, d: Pos) -> Rat }

+ :: fn (a, b: Rat) -> Rat
{;; todo: type coercion
 ;; error reports for overloads is so bad
 n : Z   := a.n * +(b.d) + b.n * +(a.d);
 d : Pos := a.d * b.d;
 n / d
 }

add1 :: (a: Pos) -> a+1 = ++(a)
{fork a
 {1 : ,
  ++: rewrite add1(a.p)}}

addSRight :: (a,b: Pos) -> a + ++(b) = ++(a+b)
{fork a
 {1 :,
  ++: rewrite addSRight(a.p, b)}}

addCommutative :: (a, b: Pos) -> (a + b = b + a)
{fork a
 {1 : rewrite add1(b),
  ++:
  rewrite addSRight(b, a.p);
  rewrite addCommutative(a.p, b)}}

;; todo #cutnpaste collapse these abstract algebra down maybe
addAssociative :: (a,b,c: Pos) -> (a+b)+c = a+b+c
{fork a
 {1 : ,
  ++: rewrite addAssociative(a.p, b, c)}}

mulDistributive :: (a,b,c: Pos) -> a*c+b*c = (a+b)*c
{fork a
 {1: ,
  ++:
  rewrite addAssociative(c, (a.p * c), (b * c));
  rewrite mulDistributive(a.p, b, c)}}

mulAssociative :: (a,b,c: Pos) -> (a*b)*c = a*b*c
{fork a
 {1 : ,
  ++:
  rewrite left mulDistributive(b, (a.p * b), c);
  rewrite mulAssociative(a.p, b, c)}}

mul1 :: (a: Pos) -> a*1 = a
{fork a
 {1 : ,
  ++: rewrite mul1(a.p)}}

;; breakhere;
mulCommutative :: (a,b: Pos) -> a*b = b*a
{fork a
 {1 : rewrite mul1(b),
  ++: 
  ;; x : (b + (a.p * b)) = ((b * 1) + (a.p * b)) := rewrite mul1(b);
  ;; rewrite x;
  rewrite mulCommutative(a.p, b)}}

add0 :: (a: Z) -> a+0 = a
{fork a {0: , +: , -: }}

mulDistributive :: (a,b,c: Z) -> a*c+b*c = (a+b)*c
{fork a
 {0: ,
  +: fork b {0: add0((+(a.v) * c)), +: , -: },
  -: }}

addAssociative :: (a,b,c: Rat) -> (a+b)+c = a+b+c
{rewrite(mulAssociative(a.d, b.d, c.d));
 }
