#load "boolean.rea"
#load "nat.rea"

;; print_raw (x: False) -> (x = x);
;; print_raw false & true | true & false | true;

;; print_raw &(true, |(false,true,),);
;; print_raw false & true | true & false | true;

;; print_raw =(_, true, false);

typecheck :: fn (id: (A: Type, a: A) -> a=a, b: Bool) -> b=b
{return id(Bool, b)}

typecheckAlpha :: (a,b,c: Bool, a=false) -> a & b = a & c
{=> false & b = a & c
 => false & b = false & c}

#should_fail
typecheck1 :: fn (id: (A: Type, a: A) -> a=a, b: Bool) -> b=b
{return b}
typecheck2 :: fn (id: (A: Type, a: A) -> a=a, a,b: Bool) -> b=b
{return id(Bool, a)}
typecheckBeta :: (a,b,c: Bool, a=false) -> a & b = a & c
{}
#should_fail off

check_truth false & true = false;
check_truth false & true | true = true;

testAbstraction :: fn (a, b: Bool) -> Bool
{fork a
 {true : return b,
  false: fork b {false: return a, true: return false}}}

check andAssociative(true, false, true) : ((true & false) & true = true & false & true);

#should_fail
dependentTypeFailTest :: fn (T: Type, A: T, a: A) -> a=a
{}
#should_fail off

dependentTypeTest :: fn (A: Type, a: A) -> a=a
{}
check dependentTypeTest(Bool, true): true=true;

testComplexFork :: fn (a, b: Nat) -> Nat
{apb := a+b;
 fork apb
 {0 : return 0,
  ++: return apb.p}}
check_truth testComplexFork(0, 0) = 0;
check_truth testComplexFork(1, 1) = 1;

testLocalVariable :: fn (x: Nat) -> Nat
{a := 3;
 b := 2;
 return a + x + b}
check_truth testLocalVariable(1) = 6;

#should_fail
reproLet :: fn (a: Nat) -> Nat {b : Bool := true; return b}
#should_fail off

#should_fail 
testCurryingWeird :: fn (a: Nat) -> (b, c: Nat) -> (a+b)+c = a+(b+c)
{fork a
 {++:
  ;; NOTE: the "a.p" is the weird part, which depends on rewrite rule to work,
  ;; and we need to support it.
  out : (b',c': Nat) -> (a.p+b')+c' = a.p+b'+c' := fn { return addAssociative(a.p, b', c') }
  return out,

  0:
  out : (b, c: Nat) -> (a+b)+c = a+b+c := fn { return addAssociative(a, b, c) }
  return out}}
#should_fail off

testCurrying2 :: fn (a, b, c: Nat) -> (a+b)+c = a+(b+c)
{fun : (b',c': Nat) -> (a+b')+c' = a+(b'+c') := fn { return addAssociative(a, b', c') };
 return fun(b,c)}

#should_fail
testCurrying2Fail :: fn (a, b, c: Nat) -> (a+b)+c = a+(b+c)
{fun : (c',b': Nat) -> (a+b')+c' = a+(b'+c') := fn { return addAssociative(a, b', c') }
 return fun(b,c)}
#should_fail off

testLocalFunction :: fn (a: Nat) -> Nat
{b := 3;
 f : (n: Nat) -> Nat := fn { return n*b };
 fork a {0: return 4, ++: return f(a)}}
check_truth testLocalFunction(2) = 6;

testArrowEvaluation :: fn (A: Type) -> (a: A) -> A {return fn {return a}}

testFunctionPointer :: fn (a,b: Bool) -> Bool
{foo : (x: Bool) -> Bool := fn {return x & b};
 d := false;
 return foo(a);}
check_truth testFunctionPointer(true,true) = true;

testFunctionPointerHelper :: fn () -> (a,b,c: Bool) -> Bool {return fn {return c}}
testFunctionPointerMore :: fn (a: Bool) -> Bool
{foo := testFunctionPointerHelper();
 return foo(true,false,a);}
check_truth testFunctionPointerMore(false) = false;

testConstantInFunctionHelper :: fn () -> Nat {a := 4; return a}
testConstantInFunction :: fn () -> Nat {b := testConstantInFunctionHelper(); return b}
check_truth testConstantInFunction() = 4;

;; showing off now that we have arrow type normalization
mulPosv2 :: (a,b: Nat, a_positive: a != 0, b_positive: b != 0) -> a*b != 0
{norm a_positive; norm b_positive;
 fork a
 {0 : return fn {return a_positive(_)},
  ++: ;; goal: (b + a.p * b = 0) -> False
  return fn {fork b {0: return b_positive(_),
                       ++: norm(seek(b + a.p * b = 0)); seek}}}}

testExecutionModel :: (a,b: Nat) -> (x: Nat) -> Nat
{
 return(fn(x: Nat) -> Nat {fy := fn(y: Nat) -> Nat {return a+b+x+y;};
                           return fy(a)})
 }
check_truth testExecutionModel(1,2)(1) = 5;

oneIsNotZero : 1 != 0 := prove {norm; return fn {seek}};
test_eval mulPos(1,1,oneIsNotZero,oneIsNotZero);
;; print mulPos;

somethingWicked :: fn (a,b,c: Nat) -> Type {return (p: a=b) -> (q: b=c) -> a=c}
somethingWickedUsage :: () -> (x,y,z: Nat) -> (somethingWicked(x,y,z))
{norm;
 return fn {return fn {return fn {rewrite p; rewrite q}}}}

StructWithFunction :: union {makeStructWithFunction(a: Nat, b: (E: a=0) -> False)}
oneEqualZeroImpliesFalse : ((E: 1=0) -> False) := prove {norm; return fn {return E}};
testFunctionInComposite :: fn (x: StructWithFunction, E: x.a = 0) -> False
{return x.b(E)}
testFunctionInCompositeUsage :: (Wrong: 1=0) -> False
{
 obj := testFunctionInComposite(makeStructWithFunction(1, oneEqualZeroImpliesFalse), Wrong);
 return obj
 }
;; print testFunctionInCompositeUsage;

foo :: (a: Bool) -> union {(p: a=false), (p: a=true)}
{fork a
 {false return ctor[0](_),
  true  return ctor[1](_),}}

True :: union {truth}

arrowTypeUnification :: (x: True) -> (a: True) -> a=x {return fn {fork a {truth: fork x {truth: }}}}
test_eval arrowTypeUnification(truth);
arrowTypeUnificationTest :: (y: True) -> (b: True) -> b=y {return arrowTypeUnification(y)}

#should_fail
check truth: true = false;
#should_fail off

RatTest :: union {/(n,d: Nat, _dnot0: d != 0)}
+ :: fn (a, b: RatTest) -> RatTest
{return /(a.n * b.d + b.n * a.d,
          a.d * b.d,
          mulPos(a.d, b.d, a._dnot0, b._dnot0))}

BigStruct :: union {bigStruct(r: RatTest)}
testBigStruct :: (big : BigStruct) -> (big.r.d != 0) {return big.r._dnot0}
testRatArrow :: fn (r: RatTest) -> r.d != 0 { return r._dnot0 }

SandwichEnd :: union {sandwichEndBool(b: Bool),
                      sandwichEndNat(n: Nat)}
SandwichMiddle :: union {makeSandwichMiddle(e: SandwichEnd)}  ;; a struct
Sandwich :: union
{
 sandwichBool(b: Bool),
 sandwichMiddle(m1: SandwichMiddle, m2: SandwichMiddle)
 }
useSandwich :: fn (sandwich: Sandwich) -> Nat
{
 fork sandwich
 {
  sandwichBool:   return 0,
  sandwichMiddle: fork sandwich.m2.e {sandwichEndBool: return 0,
                                      sandwichEndNat:  return sandwich.m2.e.n}
  }
 }
check_truth useSandwich(sandwichMiddle(makeSandwichMiddle(sandwichEndBool(true)),
                                       makeSandwichMiddle(sandwichEndNat(2)))) = 2;

#should_fail
check 1+2: RatTest;
#should_fail off

testFillingHole :: (xdebug: Nat, x_positive: xdebug!=0, P: xdebug=0) -> False
{norm x_positive;
 fork (xdebug)
 {0 : norm x_positive; return x_positive(_),
  ++: norm P; return P}
 }

unionRebasing :: (a: Nat) -> union {(a = a)}
{return ctor[0](prove(a=a) {})}

testAnonymousParameter :: fn (A: Type, A) -> A
{ seek }
;; print testAnonymousParameter;

testFillHole :: (a: Nat) -> a + 0 = a {}

testStructAsHint :: (u: union {(v: true=false)}) -> true=false
{}

twiceApplier :: fn($A: Type, op: (x,y: A) -> A, a: A) -> A
{return op(a,a)}

testPolymorphSolver :: fn(n: Nat) -> Nat
{return twiceApplier(+, n)}

check_truth testPolymorphSolver(3) = 6;

;; ---------------------------
;; The Manhattan algebra test!
;; ---------------------------

;; check_truth fold(overload(+, Nat), 1 cons single(2)) = 3;
;; test_eval(single(1) + single(2));
;; check_truth ((1 cons single(2)) + single(3)) = (1 cons (2 cons single(3)));

;; test_eval test_sort([0]);
;; test_eval test_sort([2, 0]);
;; test_eval test_sort([0, 2]);

;; testSortList :: () -> (Permute([2, 0, 4, 3, 1], [0, 1, 2, 3, 4]))
;; {
;;  return test_sort([2, 0, 4, 3, 1]);
;;  }

;; algebraTest :: (a,b,c,d,e,f: Nat) -> ((a+b)+c)+(d+e)+f = fold(+, [a,b,c,d,e,f])
;; {
;;  return algebra_norm(((a+b)+c)+(d+e)+f)
;;  }

;; algebraTest2 :: (a,b,c,d,e,f: Nat) -> (((c+e)+a)+(b+f)+d) = fold(+, [a,b,c,d,e,f])
;; {
;;  return algebra_norm(((c+e)+a)+(b+f)+d)
;;  }


;; ----
;; List (Lists that can be empty)
;; ----

List :: union($$ListType: Type)
{nil,
 cons(head: ListType, tail: List(ListType))}

+ :: fn($T: Type, l,m: List(T)) -> List(T)
{fork l
 {nil  return m,
  cons return l.head cons (l.tail + m)}}

nonEmpty :: fn ($A: Type, list: List(A)) -> Type
#expand
{return list != nil(A)}

concatNonEmpty :: (T:Type, l,m: List(T), nonEmpty(l), nonEmpty(m)) -> nonEmpty(l+m)
#hint
{fork l {nil, cons}}

;; NOTE "$$" means "poly"
Permute :: union($$T: Type, List(T), List(T))
{
 permuteSame(l: List(T)) -> Permute(l,l)
 ,
 permute(a: T, $l,$b,$c: List(T), recurse: Permute(l, b+c)) ->
 Permute(a cons l, b + (a cons c))
 }

;;
;; PList (Populated list)
;;

fold :: fn($A: Type, op: (a,b: A) -> A, a: A, tail: List(A)) -> A
#no_print_as_binop
{fork tail
 {nil return a,
  cons
  return a op fold(op, tail.head, tail.tail)}}

foldConcat :: ($T: Type, op: (a,b: T) -> T,
               associative: (a,b,c: T) -> (a op b) op c = a op b op c,
               a,b: T, l,m: List(T)) -> (fold(op, a, l + (b cons m)) =
                                         fold(op, a cons l) op fold(op, b cons m))
#hint
{fork l
 {single,
  cons
  rewrite associative(l.head, fold(op, l.tail), fold(op, m));
  rewrite foldConcat(op, associative, l.tail, m);
  }}

foldPermute :: ($T: Type,
                op: (a,b: T) -> T,
                associative: (a,b,c: T) -> (a op b) op c = a op b op c,
                commutative: (a,b: T) -> a op b = b op a,
                a,b: T, l,m: List(T),
                p: Permute(a cons l, b cons m)) -> fold(op, a, l) = fold(op, b, m)
{
 fork p
 {permuteSame
  norm p.same;
  rewrite seek(a = b);
  rewrite seek(l = m);
  ,

  ;; bookmark Please, make things better, for the children
  permute
  norm p.al_destruct;
  rewrite seek(a = p.a);
  rewrite seek(l = p.l);
  fork p.b
  {nil
   norm p.bac_destruct;
   rewrite seek(b=p.a);
   rewrite seek(m=p.c);
   norm p.recurse;

   prove (p.a cons p.l) Permute (p.a cons p.c)
   {prove (p.a cons p.l = p.a cons p.l) {} as x;
    prove (p.a cons p.c = (nil(T) + (p.a cons p.c))) {} as y;
    prove (Permute(p.l, nil(T) + p.c)) {norm;} as z;
    return permute(x, y, z)}

   return foldPermute(...)
   ,

   cons
   }
  ;; norm;
  ;; p.a op fold(op, p.l) = fold(op, p.b + (p.a cons p.c))
  ;; => p.a op fold(op, p.l) = fold(op, p.b) op fold(op, p.a cons p.c) {foldConcat}
  ;; => p.a op fold(op, p.l) = fold(op, p.b) op p.a op fold(op, p.c)
  ;; => p.a op fold(op, p.l) = (p.a op fold(op, p.c)) op fold(op, p.b) {commutative}
  ;; => p.a op fold(op, p.l) = p.a op fold(op, p.c) op fold(op, p.b) {associative}
  ;; => p.a op fold(op, p.l) = p.a op fold(op, p.b) op fold(op, p.c) {commutative}
  ;; => p.a op fold(op, p.l) = p.a op fold(op, p.b + p.c);
  ;; prove fold(op, p.l) = fold(op, p.b + p.c) {return foldPermute(...)} as e;
  ;; rewrite e,
  }
 }

provePermuteHelper :: fn(T: Type, a,b,c: PList(T), p: Permute(a,b), e: b=c) -> Permute(a,c)
{rewrite <- e;}

;; toList :: fn($T: Type, l: PList(T)) -> List(T)
;; {fork l
;;  {single return l.head cons nil(T),
;;   cons   return l.head cons toList(l.tail)}}

;; toListNonNil :: ($T: Type, l: PList(T)) -> toList(l) != nil(T)
;; {fork l {single, cons}}

;; toListEq :: ($T: Type, $l,$m: PList(T), e: toList(l) = toList(m)) -> l = m
;; #norm(e)
;; {
;;  fork l {single
;;          fork m {single,
;;                  cons
;;                  prove(toList(m.tail) = nil(T)) {rewrite e.1} as p
;;                  return toListNonNil(m.tail)(p)
;;                  },
;;          cons
;;          fork m {single return toListNonNil(l.tail)(e.1),
;;                  cons   return ctor[0](e.0, toListEq(e.1))}
;;          }
;;  }

toPList :: fn($A: Type, a: A, l: List(A)) -> PList(A)
{fork l
 {nil  return single(a),
  cons return a cons toPList(l.head, l.tail)}}

permuteEquivalent :: ($A: Type, a,b: A, l,m: List(A),
                      p: (a cons l) Permute (b cons m))
-> toPList(a, l) Permute toPList(b, m)
{fork p
 {permuteSame
  norm p.same; rewrite seek(a=b); rewrite seek(l=m); return permuteSame(...),

  permute 
  fork p.b
  {nil
   ;; eg [0,2,3] Permute [0,3,2]
   prove (b cons m = p.a cons p.c) ;; eg b = 3, m = [2]
   {=> b cons m = p.b + (p.a cons p.c)}

   prove (p.l Permute p.c)  ;; eg [2,3] Permute [3,2]
   {=> p.l Permute p.b + p.c}

   norm p.al_destruct;
   rewrite(seek(a = p.a));
   rewrite(seek(l = p.l));
   norm p.bac_destruct;
   rewrite(seek(b = p.a));
   rewrite(seek(m = p.c));
   prove ((p.a cons p.l) Permute (p.a cons p.c))
   {=> (p.a cons p.l) Permute (nil(A) + (p.a cons p.c));
    return permute(p.a, p.l,nil(A),p.c,_,_,_)}
   return permuteEquivalent(...)
   ,
   cons
   }}}
