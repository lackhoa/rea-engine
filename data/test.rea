#load "boolean.rea"
#load "nat.rea"

#should_fail
check truth: true = false;
#should_fail off

RatTest :: union
{
 / : (n,d: Nat, _dnot0: d != 0) -> RatTest
 }

BigStruct :: union
{
 makeBigStruct : (r: RatTest) -> BigStruct
 }

testBigStruct :: fn (big : BigStruct) -> (big.r.d != 0)
{
 big.r._dnot0
 }

testRatArrow :: fn (r: RatTest) -> r.d != 0 { r._dnot0 }

testRatArrow2 :: fn () -> (a: RatTest) -> (a.d = a.d)
{
 out :: fn (b: RatTest) -> (b.d = b.d) {}
 out
 }

+ :: fn (a, b: RatTest) -> RatTest
{
 /(a.n * b.d + b.n * a.d,
   a.d * b.d,
   multiplyPos(a.d, b.d, a._dnot0, b._dnot0))
 }

Nat+ :: union
{1,
 ++: (p: Nat+) -> Nat+}

+ :: fn (a, b: Nat+) -> Nat+
{fork a
 {1 : ++(b),
  ++: ++(a.p + b)}}

2 : Nat+ := ++(1);
3 : Nat+ := ++(2);
check 1+2: Nat;
check 1+2: Nat+;
#should_fail
check 1+2: RatTest;
#should_fail off

* :: fn (n, m: Nat+) -> Nat+
{fork n
 {1  : m,
  ++ : m + n.p * m}}

Z :: union
{0,
 ;; todo: These maybe not work work as unary operators?
 +: (v: Nat+) -> Z,
 -: (v: Nat+) -> Z}

;; - :: (a: Nat+, b: Nat+) -> Nat+
;; {;; assuming that a > b
;;  fork a
;;  {1 : 1,
;;   ++: fork b {1: 1, ++: -(a.p, b.p)}}}

;; compare :: (a: Nat+, b: Nat+) -> Nat+
;; {fork a
;;  {1  : fork b {1: 0, ++: -},
;;   ++ : fork b {1: +, ++: compare(a.p, b.p)}}}

+ :: fn (a, b: Z) -> Z
{fork a
 {0: b,

  +:
  fork b
  {0: a,
   +: +(a.v + b.v),
   -:  ;; a positive, b negative
   fork (a.v)
   {1 : fork (b.v) {1: 0, ++: -(b.v.p)},
    ++: fork (b.v) {1: +(a.v.p), ++: +(a.v.p) + -(b.v.p)}}},

  -:
  fork b
  {0: a,
   +: ;; a negative, b positve: symmetric case
   b + a,
   -: ;; both negative
   -(a.v + b.v)}}}

;; NOTE: this is negation, not to be confused with the actual constructor "-" for Z
- :: fn (a: Z) -> Z
{fork a {0: 0, +: -(a.v), -: +(a.v)}}

* :: fn (a,b : Z) -> Z
{fork a
 {0: 0,
  +: fork b {0: 0, +: +(a.v * b.v), -: -(a.v * b.v)},
  -: -(+(a.v) * b)}}

Rat :: union { /: (n: Z, d: Nat+) -> Rat }

+ :: fn (a, b: Rat) -> Rat
{;; todo: type coercion
 ;; error reports for overloads is so bad
 n : Z   := a.n * +(b.d) + b.n * +(a.d);
 d : Nat+ := a.d * b.d;
 n / d
 }

add1 :: (a: Nat+) -> a+1 = ++(a)
{fork a
 {1 : ,
  ++: rewrite add1(a.p)}}

addSRight :: (a,b: Nat+) -> a + ++(b) = ++(a+b)
{fork a
 {1 :,
  ++: rewrite addSRight(a.p, b)}}

addCommutative :: (a, b: Nat+) -> (a + b = b + a)
{fork a
 {1 : rewrite add1(b),
  ++:
  rewrite addSRight(b, a.p);
  rewrite addCommutative(a.p, b)}}

;; todo #copypasta collapse these abstract algebra down maybe
addAssociative :: (a,b,c: Nat+) -> (a+b)+c = a+b+c
{fork a
 {1 : ,
  ++: rewrite addAssociative(a.p, b, c)}}

mulDistributive :: (a,b,c: Nat+) -> a*c+b*c = (a+b)*c
{fork a
 {1: ,
  ++:
  rewrite addAssociative(c, (a.p * c), (b * c));
  rewrite mulDistributive(a.p, b, c)}}

mulAssociative :: (a,b,c: Nat+) -> (a*b)*c = a*b*c
{fork a
 {1 : ,
  ++:
  rewrite <- mulDistributive(b, (a.p * b), c);
  rewrite mulAssociative(a.p, b, c)}}

mul1 :: (a: Nat+) -> a*1 = a
{fork a
 {1 : ,
  ++: rewrite mul1(a.p)}}
;; print mul1;

mulSRight :: (a,b: Nat+) -> a * ++(b) = a + a*b
{fork a
 {1:,
  ++:
  => ++(b + a.p * ++(b))   = ++(a.p + b + a.p*b)
  => ++(b + a.p + a.p*b)   = ++(a.p + b + a.p*b) { mulSRight(a.p, b) }
  => ++((a.p + a.p*b) + b) = ++(a.p + b + a.p*b) { addCommutative(b, a.p + a.p*b) }
  => ++(a.p + a.p*b + b)   = ++(a.p + b + a.p*b) { addAssociative(a.p, a.p*b, b) }
  => ++(a.p + a.p*b + b)   = ++(a.p + a.p*b + b) { addCommutative(b, a.p*b) }}}
;; print(mulSRight);

mulCommutative :: (a,b: Nat+) -> a*b = b*a
{fork a
 {1 : rewrite mul1(b),
  ++: 
  => b + a.p*b = b * ++(a.p)
  => b + a.p*b = b + b*a.p { mulSRight(b, a.p) }
  => b + a.p*b = b + a.p*b { <- mulCommutative(a.p, b) }}}

add0 :: (a: Z) -> a+0 = a
{fork a {0: , +: , -: }}

mulDistributive :: (a,b,c: Z) -> a*c+b*c = (a+b)*c
{fork a
 {0: ,
  +: fork b {0: add0((+(a.v) * c)), +: , -: },
  -: }}

addAssociative :: (a,b,c: Rat) -> (a+b)+c = a+b+c
{rewrite(mulAssociative(a.d, b.d, c.d))}
