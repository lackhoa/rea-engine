#load "nat.rea"

Natp :: union {1, ++(p: Natp)}

+ :: fn(a,b: Natp) -> Natp
{fork a
 {1:  return ++(b),
  ++: return ++(a.p + b)}}

* :: fn(a,b: Natp) -> Natp
{
 fork a
 {
  1:  return b,
  ++: return b + (a.p * b),
  }
 }

add1 :: (a: Natp) -> a+1 = ++(a)
{
 fork a
 {
  1:  ,
  ++: rewrite add1(a.p)
  }
 }

addS :: (a,b: Natp) -> a + ++(b) = ++(a + b)
{
 fork a
 {
  1,
  ++ rewrite addS(a.p, b)
  }
 }

addCommutative :: (a,b: Natp) -> (b+a = a+b)
#hint
{
 fork a
 {
  1: rewrite add1(b),
  ++: rewrite addS(b, a.p); rewrite addCommutative(a.p, b)
  }
 }

addAssociative :: (a,b,c: Natp) -> (a+b)+c = a+b+c
#hint
{
 fork a
 {
  1,
  ++ rewrite addAssociative(a.p, b, c)
  }
 }

mulDistributive :: (a,b,c: Natp) -> a*c+b*c = (a+b)*c
#hint
{
 fork a
 {
  1,
  ++ ;; (c + a.p * c) + b * c = c + (a.p + b) * c
  => c + (a.p * c + b * c) = c + (a.p + b) * c {addAssociative}
  => c + ((a.p + b) * c) = c + (a.p + b) * c {mulDistributive(a.p,b,c)}
  }
 }

mulAssociative :: (a,b,c: Natp) -> (a*b)*c = a*b*c
{fork a
 {1 : ,
  ++:
  rewrite <- mulDistributive(b, (a.p * b), c);
  rewrite mulAssociative(a.p, b, c)}}

mul1 :: (a: Natp) -> a*1 = a
{fork a
 {1 : ,
  ++: rewrite mul1(a.p)}}
;; print mul1;

mulSRight :: (a,b: Natp) -> a * ++(b) = a + a*b
{fork a
 {1:,
  ++:
  => ++(b + a.p * ++(b))   = ++(a.p + b + a.p*b) {}
  => ++(b + a.p + a.p*b)   = ++(a.p + b + a.p*b) { mulSRight(a.p, b) }
  => ++((a.p + a.p*b) + b) = ++(a.p + b + a.p*b) { addCommutative }
  => ++(a.p + a.p*b + b)   = ++(a.p + b + a.p*b) { addAssociative(a.p, a.p*b, b) }
  => ++(a.p + a.p*b + b)   = ++(a.p + a.p*b + b) { addCommutative }}}
;; print(mulSRight);

mulCommutative :: (a,b: Natp) -> a*b = b*a
#hint
{fork a
 {1 : rewrite mul1(b),
  ++: ;; b + a.p*b = b * ++(a.p)
  => b + a.p*b = b + b*a.p { mulSRight(b, a.p) }
  => b + a.p*b = b + a.p*b { mulCommutative(a.p, b) }}}

mulAssociative :: (a,b,c: Natp) -> (a*b)*c = a*b*c
#hint
{fork a
 {1,
  ++ ;; (b + a.p * b) * c = b * c + a.p * b * c
  => (b + a.p * b) * c = b * c + (a.p * b) * c {mulAssociative(a.p, b, c)}
  => (b + a.p * b) * c = (b + a.p * b) * c     {mulDistributive}
  }}

;; todo this really should be built-in
successorIsDifferent :: (a: Natp, P: ++(a) = a) -> False
#norm(P)
{
 fork a
 {
  1:  return P,
  ++: return successorIsDifferent(a.p, P),
  }
 }

;; todo this really should be built-in
differentFromTwoSuccessor :: (a: Natp, P: ++(++(a)) = a) -> False
#norm(P)
{
 fork a
 {
  1:  return P,
  ++: return differentFromTwoSuccessor(a.p, P),
  }
 }

> :: fn(a, b: Natp) -> Bool
{fork a
 {1 : return false,
  ++: fork b {1: return true, ++: return a.p > b.p}}}

successorIsLarger :: (a: Natp) -> ++(a) > a = true
{fork a
 {1 : ,
  ++: return successorIsLarger(a.p)}}

gtAntiReflexive :: (a: Natp, p: a>a = true) -> False
#norm(p)
{fork a
 {1:  return p,
  ++: return gtAntiReflexive(a.p, p)}}

gtTransitive :: (a,b,c: Natp, P: a>b = true, Q: b>c = true) -> a>c = true
#norm(P,Q)
{
 fork a {
         1  return P,
         ++ fork b {1 fork Q {},
                    ++ fork c {1, ++ return gtTransitive(a.p,b.p,c.p, P, Q)}},
         }
 }

addIncreases :: (a,b: Natp) -> a+b > a = true
{
 fork a {1, ++ return addIncreases(a.p, b)}
 }

addDifferent :: (a,b: Natp, p: a+b = a) -> False
#norm(p)
{
 lem1: a + b > a = true := addIncreases(a,b);
 lem2: a > a = true     := seq {=> a + b > a = true {p}; return lem1};
 return gtAntiReflexive(a, lem2);
 }

sumCancellation :: (a,b,c: Natp, p: a + b = a + c) -> (b = c)
#norm(p)
{
 fork a {
         1  return p,
         ++ return sumCancellation(a.p,b,c, p)}
 }

=? :: fn(a,b: Natp) -> Bool
{
 fork a
 {
  1  fork b {1 return true,  ++ return false},
  ++ fork b {1 return false, ++ return a.p =? b.p}
  }
 }

add1DifferentFromAddS :: (a,b: Natp) -> a + 1 =? a + ++(b) = false
{fork a
 {1,
  ++ return add1DifferentFromAddS(a.p, b);}}

eqSymmetric :: (a,b: Natp, p: a=?b = true) -> (b=?a = true)
#norm(p)
{fork a
 {1  fork b {1, ++ return p},
  ++ fork b {1 return p,
             ++ return eqSymmetric(a.p, b.p, p)}}}

sumCancellation :: (a,b,c: Natp, p: a+b =? a+c = true) -> (b =? c = true)
#norm(p)
{
 fork a {
         1 return p,
         ++ fork b {1 fork c {1, ++ return trueNotFalse(a.p + 1 =? a.p + ++(c.p),
                                                        p,
                                                        add1DifferentFromAddS(a.p, c.p))},
                    ++ fork c
                    {1
                     lem1 := eqSymmetric(a.p + ++(b.p), a.p + 1, p);
                     lem2 := add1DifferentFromAddS(a.p, b.p);
                     return trueNotFalse(a.p + 1 =? a.p + ++(b.p), lem1, lem2)
                     ,
                     ++
                     lem1 : ++(b.p) + a.p =? ++(c.p) + a.p = true :=
                     seq {=> a.p + ++(b.p) =? ++(c.p) + a.p = true {addCommutative}
                          => a.p + ++(b.p) =? a.p + ++(c.p) = true {addCommutative}
                          return p
                          };
                     norm lem1;
                     lem2: a.p + b.p =? a.p + c.p = true :=
                     seq {
                          => b.p + a.p =? a.p + c.p = true {addCommutative}
                          => b.p + a.p =? c.p + a.p = true {addCommutative}
                          return lem1;
                          };
                     return sumCancellation(a.p,b.p,c.p, lem2)
                     }}}
 }

eqCorrect :: (a,b: Natp, p: a =? b = true) -> a = b
#norm(p)
{
 fork a
 {
  1  fork b {1, ++ return p},
  ++ fork b {1 return p, ++ rewrite eqCorrect(a.p, b.p, p)}
  }
 }

addIsDifferent :: (a,b: Natp) -> a+b =? a = false
{fork a {1, ++ return addIsDifferent(a.p, b)}}

addIsDifferent :: (a,b: Natp) -> a =? a+b = false
{fork a {1, ++ return addIsDifferent(a.p,b)}}

eqReflexive :: (a: Natp) -> a =? a = true
{fork a
 {1,
  ++ return eqReflexive(a.p)}}

addPreservesGt :: (a,b,c: Natp, p: a>b=true) -> a+c > b+c = true
#norm(p)
{
 fork a
 {
  1  fork p {},
  ++ fork b {1 rewrite addCommutative(c, a.p); return addIncreases(c, a.p),
             ++ return addPreservesGt(a.p,b.p,c, p)},
  }
 }

totalOrder :: (a,b: Natp) -> union {eq(p: a = b),
                                    gt(p: a > b = true),
                                    lt(p: b > a = true)}
{
 fork a
 {
  1 fork b {1 return ctor[0](_), ++ return ctor[2](_)},
  ++ fork b
  {
   1 return ctor[1](_),
   ++
   ind := totalOrder(a.p, b.p);
   fork ind {eq lem := ind.p; return ctor[0](seq{rewrite lem}),
             gt return ctor[1](ind.p),
             lt return ctor[2](ind.p)} 
   }
  }
 }

differentFromPlus :: (a: Natp, b: Natp, p: a = a+b) -> False
#norm(p)
{
 fork a
 {
  1  return p,
  ++ return differentFromPlus(a.p, b, p)
  ,
  }
 }

algebra_declare Natp;
