#load "nat.rea"

Natp :: union {1, ++(p: Natp)}

+ :: fn(a,b: Natp) -> Natp
#tag(Natp)
{fork a
 {1:  return ++(b),
  ++: return ++(a.p + b)}}

* :: fn(a,b: Natp) -> Natp
#tag(Natp)
{
 fork a
 {
  1:  return b,
  ++: return b + (a.p * b),
  }
 }

add1 :: (a: Natp) -> a+1 = ++(a)
{
 fork a
 {
  1:  ,
  ++: rewrite  add1(a.p)
  }
 }

addS :: (a,b: Natp) -> a + ++(b) = ++(a + b)
{
 fork a
 {
  1,
  ++ rewrite  addS(a.p, b)
  }
 }

addCommutative :: (a,b: Natp) -> (a+b = b+a)
#hint #tag(Natp)
{fork a
 {1: rewrite  add1(b),
  ++: rewrite  addS(b, a.p); rewrite  addCommutative(a.p, b)}}

addAssociative :: (a,b,c: Natp) -> (a+b)+c = a+b+c
#hint #tag(Natp)
{fork a
 {1,
  ++ rewrite  addAssociative(a.p, b, c)}}

mulDistributive :: (a,b,c: Natp) -> (a+b)*c = a*c+b*c
#hint #tag(Natp, right)
{fork a
 {1,
  ++
  => c + (a.p + b) * c = c + (a.p * c + b * c) {addAssociative}
  => c + (a.p + b) * c = c + ((a.p + b) * c) {mulDistributive(a.p,b,c)}}}

mul1 :: (a: Natp) -> a*1 = a
{fork a
 {1 : ,
  ++: rewrite  mul1(a.p)}}
test_eval mul1;

mulSRight :: (a,b: Natp) -> a * ++(b) = a + a*b
#tag(Natp)
{fork a
 {1:,
  ++:
  => ++(b + a.p * ++(b))   = ++(a.p + b + a.p*b) {}
  => ++(b + a.p + a.p*b)   = ++(a.p + b + a.p*b) { mulSRight(a.p, b) }
  => ++((a.p + a.p*b) + b) = ++(a.p + b + a.p*b) { addCommutative }
  => ++(a.p + a.p*b + b)   = ++(a.p + b + a.p*b) { addAssociative(a.p, a.p*b, b) }
  => ++(a.p + a.p*b + b)   = ++(a.p + a.p*b + b) { addCommutative }}}
test_eval overload(mulSRight, Natp);

mulCommutative :: (a,b: Natp) -> a*b = b*a
#hint #tag(Natp)
{fork a
 {1 : rewrite  mul1(b),
  ++: ;; b + a.p*b = b * ++(a.p)
  => b + a.p*b = b + b*a.p { mulSRight(b, a.p) }
  => b + a.p*b = b + a.p*b { mulCommutative(a.p, b) }}}

mulAssociative :: (a,b,c: Natp) -> (a*b)*c = a*b*c
#hint #tag(Natp)
{fork a
 {1,
  ++ ;; (b + a.p * b) * c = b * c + a.p * b * c
  => (b + a.p * b) * c = b * c + (a.p * b) * c {mulAssociative(a.p, b, c)}
  => (b + a.p * b) * c = (b + a.p * b) * c     {mulDistributive}
  }}

;; todo this really should be built-in
successorIsDifferent :: (a: Natp, P: ++(a) = a) -> False
#norm(P)
{
 fork a
 {
  1:  return P,
  ++: return successorIsDifferent(a.p, P)
  ,
  }
 }

;; todo this really should be built-in
differentFromTwoSuccessor :: (a: Natp, P: ++(++(a)) = a) -> False
#norm(P)
{fork a
 {1:  return P,
  ++: return differentFromTwoSuccessor(a.p, P)}}

> :: fn(a,b: Natp) -> Bool
{fork a
 {1 : return false,
  ++: fork b {1: return true, ++: return a.p > b.p}}}

successorIsLarger :: (a: Natp) -> ++(a) > a = true
{fork a
 {1  ,
  ++ return successorIsLarger(a.p)}}

gtAntiReflexive :: (a: Natp, p: a>a = true) -> False
#norm(p)
{fork a
 {1:  return p,
  ++: return gtAntiReflexive(a.p, p)}}

gtTransitive :: (a,b,c: Natp, P: a>b = true, Q: b>c = true) -> a>c = true
#norm(P,Q)
{
 fork a {
         1  return P,
         ++ fork b {1 fork Q {},
                    ++ fork c {1, ++ return gtTransitive(a.p,b.p,c.p, P, Q)}},
         }
 }

addIncreases :: (a,b: Natp) -> a+b > a = true
{
 fork a {1, ++ return addIncreases(a.p, b)}
 }

addDifferent :: (a,b: Natp, p: a+b = a) -> False
#norm(p)
{
 lem1: a + b > a = true := addIncreases(a,b);
 rewrite  p in lem1;
 return gtAntiReflexive(a, lem1);
 }

sumCancellation :: (a,b,c: Natp, p: a + b = a + c) -> (b = c)
#norm(p)
{
 fork a {
         1  return p,
         ++ return sumCancellation(a.p,b,c, p)}
 }

=? :: fn(a,b: Natp) -> Bool
{
 fork a
 {
  1  fork b {1 return true,  ++ return false},
  ++ fork b {1 return false, ++ return a.p =? b.p}
  }
 }

add1DifferentFromAddS :: (a,b: Natp) -> a + 1 =? a + ++(b) = false
{fork a
 {1,
  ++ return add1DifferentFromAddS(a.p, b);}}

eqSymmetric :: (a,b: Natp, p: a=?b = true) -> (b=?a = true)
#norm(p)
{fork a
 {1  fork b {1, ++ return p},
  ++ fork b {1 return p,
             ++ return eqSymmetric(a.p, b.p, p)}}}

sumCancellation :: (a,b,c: Natp, p: a+b =? a+c = true) -> (b =? c = true)
#norm(p)
{
 fork a {
         1 return p,
         ++ fork b
         {1
          fork c
          {1,
           ++
           prove (a.p + 1 =? a.p + ++(c.p) = false) {return add1DifferentFromAddS(a.p, c.p)} as x;
           rewrite  x in p;
           norm p;
           },
          ++ fork c
          {1
           lem1 := eqSymmetric(a.p + ++(b.p), a.p + 1, p);
           lem2 := add1DifferentFromAddS(a.p, b.p);
           rewrite  lem1 in lem2;
           norm lem2;
           ,
           ++
           lem1 : ++(b.p) + a.p =? ++(c.p) + a.p = true :=
           prove {=> a.p + ++(b.p) =? ++(c.p) + a.p = true {addCommutative}
                  => a.p + ++(b.p) =? a.p + ++(c.p) = true {addCommutative}
                  return p
                  };
           norm lem1;
           lem2: a.p + b.p =? a.p + c.p = true :=
           prove {
                  => b.p + a.p =? a.p + c.p = true {addCommutative}
                  => b.p + a.p =? c.p + a.p = true {addCommutative}
                  return lem1;
                  };
           return sumCancellation(a.p,b.p,c.p, lem2)
           }}}
 }

eqCorrect :: (a,b: Natp, p: a =? b = true) -> a = b
#norm(p)
{
 fork a
 {
  1  fork b {1, ++ return p},
  ++ fork b {1 return p, ++ rewrite  eqCorrect(a.p, b.p, p)}
  }
 }

addIsDifferent :: (a,b: Natp) -> a+b =? a = false
{fork a {1, ++ return addIsDifferent(a.p, b)}}

addIsDifferent :: (a,b: Natp) -> a =? a+b = false
{fork a {1, ++ return addIsDifferent(a.p,b)}}

eqReflexive :: (a: Natp) -> a =? a = true
{fork a
 {1,
  ++ return eqReflexive(a.p)}}

addPreservesGt :: (a,b,c: Natp, p: a>b=true) -> a+c > b+c = true
#norm(p)
{
 fork a
 {
  1  fork p {},
  ++ fork b {1 rewrite  addCommutative(a.p, c); return addIncreases(c, a.p),
             ++ return addPreservesGt(a.p,b.p,c, p)},
  }
 }

TotalOrder :: union (^a,^b: Natp)
{eq(p: a = b),
 gt(p: a>b = true),
 lt(p: b>a = true)}

totalOrder :: (a,b: Natp) -> TotalOrder(a,b)
{fork a
 {1 fork b {1  return eq(_),
            ++ return lt(_)},
  ++ fork b
  {1 return gt(_),
   ++
   ind := totalOrder(a.p, b.p);
   fork ind {eq return eq(prove{rewrite ind.p}),
             gt return gt(prove{norm; return ind.p}),
             lt return lt(prove{norm; return ind.p})}}}}

differentFromPlus :: (a: Natp, b: Natp, p: a = a+b) -> False
#norm(p)
{
 fork a
 {
  1  return p,
  ++ return differentFromPlus(a.p, b, p)
  }
 }

mulDistributive :: (a,b,c: Natp) -> c*(a+b) = c*a+c*b
#hint #tag(Natp, left)
{
 => (a+b)*c = c*a+c*b
 => (a+b)*c = a*c+c*b
 => (a+b)*c = a*c+b*c
 }

;; NOTE: ">" is already defined, but there's no reason not to define "<=" too.
<= :: fn(a,b: Natp) -> Bool
{fork a
 {1 : return true,
  ++: fork b {1: return false, ++: return a.p <= b.p}}}

< :: fn(a,b: Natp) -> Bool
#expand
{return ++(a) <= b}

== :: fn(a,b: Natp) -> Bool
{fork a
 {1  fork b {1  return true,
             ++ return false}
  ,
  ++ fork b {1  return false,
             ++ return a.p == b.p}}}

algebra_declare Natp;
